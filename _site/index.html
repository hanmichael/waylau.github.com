<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <meta name="description" content="Way Lau's Personal Site | www.waylau.com">
  <meta name="author" content="Way Lau">
  <meta name="keywords" content="Way Lau's Personal Site | www.waylau.com, Way Lau's Blog, 技术改变世界！, Way Lau">
  <title>Way Lau's Personal Site | www.waylau.com</title>
  <link rel="canonical" href="http://www.waylau.com">
  <link rel="icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/res/css/public.css">
  <link rel="stylesheet" href="/res/css/light.css">
  <script src="/res/js/light.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?28cf5fa48a599e39c5cc760931de942f";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
</head>
<body>
  <div id="blog">
    <div class="sidebar">
  <div class="profilepic">
    <a href="/"><img src="/res/img/icon.png" alt="logo"></img></a>
  </div>
  <h1 class="title"><a href="/">Way Lau's Blog</a></h1>
  <h2 class="sub-title">技术改变世界！</h2>
  <nav id="nav">
    <ul>
    
      <li><a href="/timing/"><i class="fa fa-clock-o"></i>&nbsp;时光机</a></li>
    
      <li><a href="/categories/"><i class="fa fa-tags"></i>&nbsp;分类</a></li>
    
      <li><a href="/tags/"><i class="fa fa-bookmark"></i>&nbsp;标签</a></li>
    
      <li><a href="http://labs.waylau.com/"><i class="fa fa-building"></i>&nbsp;示例</a></li>
    
      <li><a href="/books/"><i class="fa fa-book"></i>&nbsp;书籍</a></li>
    
      <li><a href="/about/"><i class="fa fa-paper-plane-o"></i>&nbsp;关于</a></li>
    
    </ul>
  </nav>  
  <nav id="sub-nav">
    <a class="weibo " href="http://weibo.com/waylau521" title="新浪微博" target="_blank"><i class="fa fa-weibo "></i></a>
    <a class="github" href="https://github.com/waylau" title="GitHub" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    <a class="twitter" href="https://twitter.com/waylau521" title="Twitter" target="_blank"><i class="fa fa-twitter fa-2x"></i></a>
    <a class="rss" href="/page/feed.xml" title="RSS订阅" target="_blank"><i class="fa fa-rss"></i></a>
  </nav>
  <div id="license">
    <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" title="本站所有作品采用：&#10;知识共享《署名 非商业性使用 相同方式共享 3.0》&#10;进行许可" >
    <img alt="License" height="31" width="88" src="/res/img/license.png" /></a>
  </div>
</div>
    <div class="main">
    
<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/jersey-2-spring-4-rest/">用 Jersey 2 和 Spring 4 构建 RESTful web service</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年11月22日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#jersey">jersey</a>
      </p>
    </header>
    <div class="post-main">
      <p>本文介绍了如何通过 Jersey 框架优美的在 Java 实现了 REST 的 API。CRUD 的 操作存储在 MySQL 中</p>

<h2>1. 示例</h2>

<h3>1.1 为什么</h3>

<p>Spring 可以对于 REST 有自己的实现(见 <a href="https://spring.io/guides/tutorials/rest/">https://spring.io/guides/tutorials/rest/</a>)。 但本文展示的是用 “官方” 的 方法来实现 REST ，即使用 Jersey。</p>

<h3>1.2 它是做什么的?</h3>

<p>管理 资源。 REST API 将允许创建、检索、更新和删除这样的资源。</p>

<h3>1.3 架构及技术</h3>

<p><img src="http://99btgc01.info/uploads/2014/11/Rest-Demo-Diagram.png" alt="" /></p>

<p>本示例项目使用多层结构，基于“Law of Demeter (LoD) or principle of least knowledge”（迪米特法则），是说一个软件实体要尽可能的只与和它最近的实体进行通讯。通常被表述为：talk only to your immediate friends ( 只和离你最近的朋友进行交互)。<br/>
 “talk”，其实就是对象间方法的调用。这条规则表明了对象间方法调用的原则：（1）调用对象本身的方法；（2）调用通过参数传入的对象的方法；（3）在方法中创建的对象的方法；（4）所包含对象的方法。</p>

<p>主要分为三层：</p>

<ul>
<li>第一层：Jersey 实现对 REST 的支持，拥有 <a href="http://en.wikipedia.org/wiki/Facade_pattern">外观模式</a>的角色并代理到逻辑业务层</li>
<li>业务层: 发生逻辑的地方</li>
<li>数据访问层： 是与持久数据存储（在我们的例子中是 MySql数据库)交互的地方</li>
</ul>


<p>简述下技术框架：</p>

<h4>1.3.1. Jersey (外观)</h4>

<p><a href="https://jersey.java.net/">Jersey</a> 是开源、拥有产品级别的质量，提供构建  RESTful Web Services,支持  JAX-RS APIs ，提供 <a href="https://jax-rs-spec.java.net/">JAX-RS</a> (JSR 311 &amp; JSR 339) 参考实现。</p>

<h4>1.3.2. Spring (业务层)</h4>

<p>在我看来没有什么 比 <a href="http://projects.spring.io/spring-framework/">Spring</a> 更好的办法让 pojo 具有不同的功能。 你会发现在本教程用 Jersey 2 和 Spring 4 构建 RESTful web service</p>

<h4>1.3.3. JPA 2 / Hibernate (持久层)</h4>

<p>使用 Hibernate 实现 DAO 模式。</p>

<h4>1.3.4. Web 容器</h4>

<p>用 Maven 打包成 .war 文件开源部署在任意容器。一般用 <a href="http://tomcat.apache.org/">Tomcat</a> 和 <a href="http://www.eclipse.org/jetty/">Jetty</a> ，也可以是 Glassfih, Weblogic, JBoss 或 WebSphere.</p>

<h4>1.3.5. MySQL 数据库</h4>

<p>示例数据存储在一个 MySQL 表:</p>

<p><img src="http://99btgc01.info/uploads/2014/11/database-schema.png" alt="" /></p>

<h4>1.3.6. 技术版本</h4>

<p>Jersey 2.9</p>

<p>Spring 4.0.3</p>

<p>Hibernate 4</p>

<p>Maven 3</p>

<p>Tomcat 7</p>

<p>Jetty 9</p>

<p>MySql 5.6</p>

<h3>1.4. 源码</h3>

<p>见<a href="https://github.com/waylau/RestDemo/tree/master/jersey-2-spring-4-rest">https://github.com/waylau/RestDemo/tree/master/jersey-2-spring-4-rest</a></p>

<h2>2. 配置</h2>

<p>开始呈现 REST API 的设计和实现之前,我们需要做一些配置。</p>

<h3>2.1. 项目依赖</h3>

<p><a href="https://github.com/waylau/Jersey-2.x-User-Guide/tree/master/Chapter%2022.%20Spring%20DI%20%E4%BD%BF%E7%94%A8%20Spring%20%E6%B3%A8%E5%85%A5">Jersey Spring 扩展包</a> 是必须要放在 项目 classpath 中。在 pom.xml 中添加下面依赖：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-spring3&lt;/artifactId&gt;
    &lt;version&gt;${jersey.version}&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;            
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;            
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;
    &lt;version&gt;2.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p><em>注意: jersey-spring3.jar 使用的是他自己的 Spring 库版本，所以如果你想使用自己的 (本例是使用 Spring 4.0.3.Release),你需要将这些库手动的移除。如果想看到其他 的库的依赖，请查看项目源码中的 pom.xml</em></p>

<h3>2.2. web.xml</h3>

<p>应用部署描述</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
    &lt;display-name&gt;Demo - Restful Web Application&lt;/display-name&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;
            org.springframework.web.context.ContextLoaderListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;jersey-serlvet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.glassfish.jersey.servlet.ServletContainer
        &lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
            &lt;param-value&gt;org.codingpedia.demo.rest.RestDemoJaxRsApplication&lt;/param-value&gt;            
        &lt;/init-param&gt;        
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;jersey-serlvet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;resource-ref&gt;
        &lt;description&gt;Database resource rest demo web application &lt;/description&gt;
        &lt;res-ref-name&gt;jdbc/restDemoDB&lt;/res-ref-name&gt;
        &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
        &lt;res-auth&gt;Container&lt;/res-auth&gt;
    &lt;/resource-ref&gt;    
&lt;/web-app&gt;
</code></pre>

<h4>2.2.1. Jersey-servlet</h4>

<p>注意 Jersey servlet 的配置，<code>javax.ws.rs.core.Application</code> 类定义了 JAX-RS 应用组件(root 资源 和 提供者 类) .本例使用 <code>ResourceConfig</code>, 是 Jersey 自己实现的 <code>Application</code> 类，提供了简化  JAX-RS 组件的能力。详见<a href="https://github.com/waylau/Jersey-2.x-User-Guide/blob/master/Chapter%204.%20Application%20Deployment%20and%20Runtime%20Environments%20%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/4.2.%20JAX-RS%20Application%20Model%20%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B.md">JAX-RS 应用模型</a></p>

<p><code>org.codingpedia.demo.rest.RestDemoJaxRsApplication</code> 是自己实现的 <code>ResourceConfig</code>类，注册应用的  resources, filters, exception mappers 和 feature :</p>

<pre><code>package org.codingpedia.demo.rest.service;

//imports omitted for brevity 

/**
 * Registers the components to be used by the JAX-RS application
 * 
 * @author ama
 * 
 */
public class RestDemoJaxRsApplication extends ResourceConfig {

    /**
     * Register JAX-RS application components.
     */
    public RestDemoJaxRsApplication() {
        // register application resources
        register(PodcastResource.class);
        register(PodcastLegacyResource.class);

        // register filters
        register(RequestContextFilter.class);
        register(LoggingResponseFilter.class);
        register(CORSResponseFilter.class);

        // register exception mappers
        register(GenericExceptionMapper.class);
        register(AppExceptionMapper.class);
        register(NotFoundExceptionMapper.class);

        // register features
        register(JacksonFeature.class);
        register(MultiPartFeature.class);
    }
}
</code></pre>

<p>注意：</p>

<ul>
<li><code>org.glassfish.jersey.server.spring.scope.RequestContextFilter</code> 是 Spring filter 提供了 JAX-RS 和 Spring 请求属性之间的桥梁。</li>
<li><code>org.codingpedia.demo.rest.resource.PodcastsResource</code> 这是“外观”组件，通过注解 暴露了 REST 的API。稍后会描述</li>
<li><code>org.glassfish.jersey.jackson.JacksonFeature</code>,是一个  feature ，用 Jackson JSON 的提供者来解释 JSON。</li>
</ul>


<h4>2.1.2. Spring 配置</h4>

<p>配置文件在 classpath 目录下的 spring/applicationContext.xml:</p>

<pre><code>&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:tx="http://www.springframework.org/schema/tx"    
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans    
        http://www.springframework.org/schema/beans/spring-beans.xsd

        http://www.springframework.org/schema/tx 
        http://www.springframework.org/schema/tx/spring-tx.xsd

        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:component-scan base-package="org.codingpedia.demo.rest.*" /&gt;

    &lt;!-- ************ JPA configuration *********** --&gt;
    &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;  
    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
        &lt;property name="entityManagerFactory" ref="entityManagerFactory" /&gt;
    &lt;/bean&gt;
    &lt;bean id="transactionManagerLegacy" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
        &lt;property name="entityManagerFactory" ref="entityManagerFactoryLegacy" /&gt;
    &lt;/bean&gt;    
    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceXmlLocation" value="classpath:config/persistence-demo.xml" /&gt;
        &lt;property name="persistenceUnitName" value="demoRestPersistence" /&gt;        
        &lt;property name="dataSource" ref="restDemoDS" /&gt;
        &lt;property name="packagesToScan" value="org.codingpedia.demo.*" /&gt;
        &lt;property name="jpaVendorAdapter"&gt;
            &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;
                &lt;property name="showSql" value="true" /&gt;
                &lt;property name="databasePlatform" value="org.hibernate.dialect.MySQLDialect" /&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;     
    &lt;bean id="entityManagerFactoryLegacy" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceXmlLocation" value="classpath:config/persistence-demo.xml" /&gt;
        &lt;property name="persistenceUnitName" value="demoRestPersistenceLegacy" /&gt;
        &lt;property name="dataSource" ref="restDemoLegacyDS" /&gt;
        &lt;property name="packagesToScan" value="org.codingpedia.demo.*" /&gt;
        &lt;property name="jpaVendorAdapter"&gt;
            &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;
                &lt;property name="showSql" value="true" /&gt;
                &lt;property name="databasePlatform" value="org.hibernate.dialect.MySQLDialect" /&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;        

    &lt;bean id="podcastDao" class="org.codingpedia.demo.rest.dao.PodcastDaoJPA2Impl"/&gt;    
    &lt;bean id="podcastService" class="org.codingpedia.demo.rest.service.PodcastServiceDbAccessImpl" /&gt;    
    &lt;bean id="podcastsResource" class="org.codingpedia.demo.rest.resource.PodcastsResource" /&gt;
    &lt;bean id="podcastLegacyResource" class="org.codingpedia.demo.rest.resource.PodcastLegacyResource" /&gt;

    &lt;bean id="restDemoDS" class="org.springframework.jndi.JndiObjectFactoryBean" scope="singleton"&gt;
        &lt;property name="jndiName" value="java:comp/env/jdbc/restDemoDB" /&gt;
        &lt;property name="resourceRef" value="true" /&gt;        
    &lt;/bean&gt;
    &lt;bean id="restDemoLegacyDS" class="org.springframework.jndi.JndiObjectFactoryBean" scope="singleton"&gt;
        &lt;property name="jndiName" value="java:comp/env/jdbc/restDemoLegacyDB" /&gt;
        &lt;property name="resourceRef" value="true" /&gt;        
    &lt;/bean&gt;    
&lt;/beans&gt;
</code></pre>

<p>其中 <code>podcastsResource</code>是指向 REST API 实体</p>

<h2>3. REST API (设计与实现)</h2>

<h3>3.1. 资源</h3>

<h4>3.1.1. 设计</h4>

<p>REST 中的资源主要包括下面两大思想：</p>

<ul>
<li>每个都指向了全球标示符（如，HTTP 中的 <a href="http://en.wikipedia.org/wiki/Uniform_resource_identifier">URI</a>）</li>
<li>有一个或多个表示（我们将在本示例使用 JSON 格式）</li>
</ul>


<p>REST 中的资源 一般是名词 (podcasts, customers, user, accounts 等) 而不是名词 (getPodcast, deleteUser 等）</p>

<p>本教程使用的端点有：</p>

<ul>
<li><code>/podcasts</code> – （注意复数）URI标识的资源 podcasts 集合的播客</li>
<li><code>/podcasts/{id}</code> – 通过 podcasts 的ID, URI 标识一个podcasts 资源，</li>
</ul>


<h4>3.1.2. 实现</h4>

<p>为求精简 ， podcast 只包含下列属性:</p>

<ul>
<li>id – podcast 的唯一标识</li>
<li>feed –  podcast 的 feed url</li>
<li>title – 标题</li>
<li>linkOnPodcastpedia – 链接</li>
<li>description – 描述</li>
</ul>


<p>我用了两种 Java 类来表示 podcast 代码，是为了避免 类及其属性/方法 被 JPA 和 XML/JAXB/JSON 的注释堆满了：</p>

<ul>
<li>PodcastEntity.java – JPA 注解类用在 DB 和业务层</li>
<li>Podcast.java – JAXB/JSON 注解类用在外观和业务层</li>
</ul>


<p>Podcast.java</p>

<pre><code>package org.codingpedia.demo.rest.resource;

//imports omitted for brevity

/**
 * Podcast resource placeholder for json/xml representation 
 * 
 * @author ama
 *
 */
@SuppressWarnings("restriction")
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Podcast implements Serializable {

    private static final long serialVersionUID = -8039686696076337053L;

    /** id of the podcast */
    @XmlElement(name = "id")    
    private Long id;

    /** title of the podcast */
    @XmlElement(name = "title")    
    private String title;

    /** link of the podcast on Podcastpedia.org */
    @XmlElement(name = "linkOnPodcastpedia")    
    private String linkOnPodcastpedia;

    /** url of the feed */
    @XmlElement(name = "feed")    
    private String feed;

    /** description of the podcast */
    @XmlElement(name = "description")
    private String description; 

    /** insertion date in the database */
    @XmlElement(name = "insertionDate")
    @XmlJavaTypeAdapter(DateISO8601Adapter.class)    
    @PodcastDetailedView
    private Date insertionDate;

    public Podcast(PodcastEntity podcastEntity){
        try {
            BeanUtils.copyProperties(this, podcastEntity);
        } catch (IllegalAccessException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public Podcast(String title, String linkOnPodcastpedia, String feed,
            String description) {

        this.title = title;
        this.linkOnPodcastpedia = linkOnPodcastpedia;
        this.feed = feed;
        this.description = description;

    }

    public Podcast(){}

//getters and setters now shown for brevity
}
</code></pre>

<p>转化成 JSON 输出如下</p>

<pre><code>{
    "id":1,
    "title":"Quarks &amp; Co - zum Mitnehmen-modified",
    "linkOnPodcastpedia":"http://www.podcastpedia.org/podcasts/1/Quarks-Co-zum-Mitnehmen",
    "feed":"http://podcast.wdr.de/quarks.xml",
    "description":"Quarks &amp; Co: Das Wissenschaftsmagazin",
    "insertionDate":"2014-05-30T10:26:12.00+0200"
}
</code></pre>

<h3>3.2. 方法</h3>

<p>简单的说明</p>

<ul>
<li>创建 = POST</li>
<li>读 = GET</li>
<li>更新 = PUT</li>
<li>删除 = DELETE</li>
</ul>


<p>但不是一一映射，因为 PUT 也可以创建， POST也可以用在更新。</p>

<p><em>注：读取和删除它是很清楚的，他们确实是和 GET 、DELETE一对一的映射。无论如何，REST 是一种架构风格，不是一个规范，你应该适应你的架构需要，但如果你想让你的 API 让更多的公众愿意使用它，你应该遵循一定的“最佳实践”。</em></p>

<p><code>PodcastRestResource</code> 类 是处理所有的请求</p>

<pre><code>package org.codingpedia.demo.rest.resource;
//imports
......................
@Component
@Path("/podcasts")
public class PodcastResource {
    @Autowired
    private PodcastService podcastService;
    .....................
}
</code></pre>

<p>注意 类定义前面的 <code>@Path("/podcasts")</code>，所有与 podcast 关联的资源都会出现在 这个路径下。 @Path 注解值是关联 URI 的路径。</p>

<p>在上面的例子中，该 Java 类将托管在<code>/podcasts</code> URI 路径。<code>PodcastService</code> 接口公开的业务逻辑 到 REST 外观层。</p>

<h4>3.2.1. 创建 podcast</h4>

<h4>3.2.1.1. 设计</h4>

<p>常见的的方式利用 POST 创建资源，如前所述，创建一个新的资源，可以用 POST 和 PUT 的方法，我是这样做的：</p>

<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr valign="TOP">
<td bgcolor="#808080" width="25%"><b>&nbsp; Description</b></td>
<td bgcolor="#808080" width="25%"><b>&nbsp; URI</b></td>
<td bgcolor="#808080" width="25%"><b>&nbsp; HTTP method<br>
</b></td>
<td bgcolor="#808080" width="25%"><b>&nbsp; HTTP Status response</b></td>
<iframe id="tmp_downloadhelper_iframe" style="display: none;"></iframe></tr>
<tr>
<td width="25%" height="19">&nbsp;增加新的 podcast</td>
<td width="25%">&nbsp;/podcasts/</td>
<td width="25%">
<p align="CENTER">POST</p>
</td>
<td width="25%">
<p align="CENTER">201 Created</p>
</td>
</tr>
<tr>
<td width="25%" height="19">&nbsp;增加新的 podcast (必须传所有的值)</td>
<td width="25%">&nbsp;/podcasts/{id}</td>
<td width="25%">
<p align="CENTER">PUT</p>
</td>
<td width="25%">
<p align="CENTER">201 Created</p>
</td>
</tr>
</tbody>
</table>


<p>PUT  POST 最大的区别是 ，PUT 就是把你应该事先知道资源将被创建的位置和发送所有可能值的实体。</p>

<h5>3.2.1.2. 实现</h5>

<h6>3.2.1.2.1. POST 创建一个单资源</h6>

<pre><code>/**
 * Adds a new resource (podcast) from the given json format (at least title
 * and feed elements are required at the DB level)
 * 
 * @param podcast
 * @return
 * @throws AppException
 */
@POST
@Consumes({ MediaType.APPLICATION_JSON })
@Produces({ MediaType.TEXT_HTML })
public Response createPodcast(Podcast podcast) throws AppException {
    Long createPodcastId = podcastService.createPodcast(podcast);
    return Response.status(Response.Status.CREATED)// 201
            .entity("A new podcast has been created")
            .header("Location",
                    "http://localhost:8888/demo-rest-jersey-spring/podcasts/"
                            + String.valueOf(createPodcastId)).build();
}
</code></pre>

<p>注解</p>

<ul>
<li>@POST – 指示方法响应到 HTTP POST 请求</li>
<li>@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为"application/json"</li>
<li>@Produces({MediaType.TEXT_HTML}) – 定义方法产生的媒体类型本例为 "text/html"</li>
</ul>


<p>响应</p>

<ul>
<li>成功: HTTP 状态 为 201 的 text/html 文件和头的位置指定的资源已被创建</li>
<li>错误:

<ul>
<li>400：没有足够的数据提供</li>
<li>409：冲突了。如果在服务器端被确定 具有相同的 podcast 的存在</li>
</ul>
</li>
</ul>


<h6>3.2.1.2.2. 通过 PUT 创建单资源 (“podcast”)</h6>

<p>这将执行 更新 Podcast 处理。</p>

<h6>3.2.1.2.3. 附加 – 通过表单创建 (“podcast”)资源</h6>

<pre><code>/**
 * Adds a new podcast (resource) from "form" (at least title and feed
 * elements are required at the DB level)
 * 
 * @param title
 * @param linkOnPodcastpedia
 * @param feed
 * @param description
 * @return
 * @throws AppException
 */
@POST
@Consumes({ MediaType.APPLICATION_FORM_URLENCODED })
@Produces({ MediaType.TEXT_HTML })
@Transactional
public Response createPodcastFromApplicationFormURLencoded(
        @FormParam("title") String title,
        @FormParam("linkOnPodcastpedia") String linkOnPodcastpedia,
        @FormParam("feed") String feed,
        @FormParam("description") String description) throws AppException {

    Podcast podcast = new Podcast(title, linkOnPodcastpedia, feed,
            description);
    Long createPodcastid = podcastService.createPodcast(podcast);

    return Response
            .status(Response.Status.CREATED)// 201
            .entity("A new podcast/resource has been created at /demo-rest-jersey-spring/podcasts/"
                    + createPodcastid)
            .header("Location",
                    "http://localhost:8888/demo-rest-jersey-spring/podcasts/"
                            + String.valueOf(createPodcastid)).build();
}
</code></pre>

<p>注解</p>

<ul>
<li>@POST – 指示方法响应到 HTTP POST 请求</li>
<li>@Consumes({MediaType.APPLICATION_FORM_URLENCODED}) – 定义方法可以接受的媒体类型，本例为"application/x-www-form-urlencoded"</li>
<li>@FormParam – 这个注解绑定的表单参数值包含了请求对应资源方法参数的实体。值是 URL  的解码，除非 禁用 解码的注解。</li>
<li>@Produces({MediaType.TEXT_HTML}) – 定义方法产生的媒体类型本例为 "text/html"</li>
</ul>


<p>响应</p>

<ul>
<li>成功: HTTP 状态 为 201 的 text/html 文件和头的位置指定的资源已被创建</li>
<li>错误:

<ul>
<li>400：没有足够的数据提供</li>
<li>409：冲突了。如果在服务器端被确定 具有相同的 podcast 的存在</li>
</ul>
</li>
</ul>


<h4>3.2.2. 读 podcast</h4>

<h5>3.2.2.1. 设计</h5>

<p>API 支持两种操作</p>

<ul>
<li>返回 podcast 的集合</li>
<li>根据 id 返回  podcast</li>
</ul>


<p><tbody align="center"><tr><td><b>&nbsp;Description</b></td><td><b>&nbsp;URI</b></td><td><b>&nbsp;HTTP method<br> </b></td><td><b>&nbsp;HTTP Status response</b></td><iframe id="tmp_downloadhelper_iframe" style="display: none;"></iframe></tr><tr><td>返回所有 podcast </td><td>&nbsp;/podcasts/?orderByInsertionDate={ASC|DESC}&amp;numberDaysToLookBack={val}</td><td>GET</td><td>200&nbsp;OK</td></tr><tr><td>&nbsp;添加新的 podcast (所有值都要传递)</td><td>&nbsp;/podcasts/{id}</td><td>GET</td><td>200&nbsp;OK</td></tr></tbody></p>

<p>注意到集合资源的参数–rderByInsertionDate 和 numberDaysToLookBack。在URI查询参数添加过滤器而不是路径的一部分这个是很有道理的。</p>

<h5>3.2.2.2. 实现</h5>

<h6>3.2.2.2.1. 获取所有 podcasts (“/”)</h6>

<pre><code>/**
 * Returns all resources (podcasts) from the database
 * 
 * @return
 * @throws IOException
 * @throws JsonMappingException
 * @throws JsonGenerationException
 * @throws AppException
 */
@GET
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public List&lt;Podcast&gt; getPodcasts(
        @QueryParam("orderByInsertionDate") String orderByInsertionDate,
        @QueryParam("numberDaysToLookBack") Integer numberDaysToLookBack)
        throws JsonGenerationException, JsonMappingException, IOException,
        AppException {
    List&lt;Podcast&gt; podcasts = podcastService.getPodcasts(
            orderByInsertionDate, numberDaysToLookBack);
    return podcasts;
}
</code></pre>

<p>注解</p>

<ul>
<li>@GET – 指示方法响应到 HTTP GET 请求</li>
<li>@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) – 定义方法可以接受的媒体类型，本例为"application/json" 或者 "application/xml"（在 Podcast 类前 添加  @XmlRootElement ），将返回  JSON 或者 XML 格式的 podcast 集合</li>
</ul>


<p>响应</p>

<ul>
<li>成功: HTTP 状态 为 200 的 podcast 数据集合</li>
</ul>


<h6>3.2.2.2.1. 读一个 podcast</h6>

<p>根据 id  获取一个 podcast</p>

<pre><code>@GET
@Path("{id}")
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public Response getPodcastById(@PathParam("id") Long id)
        throws JsonGenerationException, JsonMappingException, IOException,
        AppException {
    Podcast podcastById = podcastService.getPodcastById(id);
    return Response.status(200).entity(podcastById)
            .header("Access-Control-Allow-Headers", "X-extra-header")
            .allow("OPTIONS").build();
}
</code></pre>

<p>注解</p>

<ul>
<li>@GET – 指示方法响应到 HTTP GET 请求</li>
<li>@PathParam("id")- 绑定传递的参数值</li>
<li>@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) – 定义方法可以接受的媒体类型，本例为"application/json" 或者 "application/xml"（在 Podcast 类前 添加  @XmlRootElement ），将返回  JSON 或者 XML 格式的 podcast 集合</li>
</ul>


<p>响应</p>

<ul>
<li>成功: HTTP 状态 为 200 的 podcast</li>
<li>错误： 404 Not found。如果没有在数据库中找到</li>
</ul>


<h4>3.2.3. 更新 podcast</h4>

<h5>3.2.3.1. 设计</h5>

<table cellspacing="0" cellpadding="5" border="1" align="center" style="width:600px"><tbody align="center"><tr><td><b>Description</b></td><td><b>URI</b></td><td><b>HTTP method<br> </b></td><td><b>HTTP Status response</b></td></tr><tr><td>更新 podcast (<strong>完全</strong>)</td><td>&nbsp;/podcasts/{id}</td><td>PUT</td><td>200&nbsp;OK</td></tr><tr><td>&nbsp;更新 podcast (<strong>部分</strong>)</td><td>&nbsp;/podcasts/{id}</td><td>POST</td><td>200&nbsp;OK</td></tr></tbody></table>


<p>1.完全更新  – 提供所有的值
2.部分更新  – 传递部分属性值即可</p>

<h5>3.2.3.1. 实现</h5>

<h6>3.2.3.1.1. 完全更新</h6>

<p>创建或者完全更新资源</p>

<pre><code>@PUT
@Path("{id}")
@Consumes({ MediaType.APPLICATION_JSON })
@Produces({ MediaType.TEXT_HTML })
public Response putPodcastById(@PathParam("id") Long id, Podcast podcast)
        throws AppException {

    Podcast podcastById = podcastService.verifyPodcastExistenceById(id);

    if (podcastById == null) {
        // resource not existent yet, and should be created under the
        // specified URI
        Long createPodcastId = podcastService.createPodcast(podcast);
        return Response
                .status(Response.Status.CREATED)
                // 201
                .entity("A new podcast has been created AT THE LOCATION you specified")
                .header("Location",
                        "http://localhost:8888/demo-rest-jersey-spring/podcasts/"
                                + String.valueOf(createPodcastId)).build();
    } else {
        // resource is existent and a full update should occur
        podcastService.updateFullyPodcast(podcast);
        return Response
                .status(Response.Status.OK)
                // 200
                .entity("The podcast you specified has been fully updated created AT THE LOCATION you specified")
                .header("Location",
                        "http://localhost:8888/demo-rest-jersey-spring/podcasts/"
                                + String.valueOf(id)).build();
    }
}
</code></pre>

<p>注解</p>

<ul>
<li>@PUT – 指示方法响应到 HTTP PUT  请求</li>
<li>@PathParam("id")- 绑定传递的参数值</li>
<li>@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为"application/json"</li>
<li>@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为t"ext/html"</li>
</ul>


<p>响应</p>

<ul>
<li>创建

<ul>
<li>成功: HTTP 状态 为 201 Created</li>
<li>错误： 400 Bad Request。如果需要的属性值没有提供</li>
</ul>
</li>
<li>完全更新：

<ul>
<li>成功: HTTP 状态 为 200</li>
<li>错误： 400 Bad Request。如果不是所有的属性都提供</li>
</ul>
</li>
</ul>


<h6>3.2.3.1.2. 部分更新</h6>

<pre><code>//PARTIAL update
@POST
@Path("{id}")   
@Consumes({ MediaType.APPLICATION_JSON })
@Produces({ MediaType.TEXT_HTML })
public Response partialUpdatePodcast(@PathParam("id") Long id, Podcast podcast) throws AppException {
    podcast.setId(id);
    podcastService.updatePartiallyPodcast(podcast);
    return Response.status(Response.Status.OK)// 200
            .entity("The podcast you specified has been successfully updated")
            .build();   
}
</code></pre>

<p>注解</p>

<ul>
<li>@POST – 指示方法响应到 HTTP POST 请求</li>
<li>@PathParam("id")- 绑定传递的参数值</li>
<li>@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为"application/json"</li>
<li>@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为t"ext/html"</li>
</ul>


<p>响应</p>

<ul>
<li>成功: HTTP 状态 为 200 OK</li>
<li>错误： 404 Not Found。如果资源不存在</li>
</ul>


<h4>3.2.4. 删除 podcast</h4>

<h5>3.2.4.1. 设计</h5>

<table cellspacing="0" cellpadding="5" border="1" align="center" style="width:700px"><tbody align="center"><tr><td><b>Description</b></td><td><b>URI</b></td><td><b>HTTP method<br> </b></td><td><b>HTTP Status response</b></td></tr><tr><td>移除所有 podcasts</td><td>&nbsp;/podcasts/</td><td>DELETE</td><td>204 No content</td></tr><tr><td>移除特定位置的 podcast</td><td>&nbsp;/podcasts/{id}</td><td>DELETE</td><td>204 No content</td></tr></tbody></table>


<h5>3.2.4.2. 实现</h5>

<h6>3.2.4.2.1. 删除所有资源</h6>

<pre><code>@DELETE
@Produces({ MediaType.TEXT_HTML })
public Response deletePodcasts() {
    podcastService.deletePodcasts();
    return Response.status(Response.Status.NO_CONTENT)// 204
            .entity("All podcasts have been successfully removed").build();
}
</code></pre>

<p>注解</p>

<ul>
<li>@DELETE – 指示方法响应到 HTTP DELETE  请求</li>
<li>@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为"text/html"</li>
</ul>


<p>响应</p>

<ul>
<li>返回 html  文档</li>
</ul>


<h6>3.2.4.2.2. 删除一个资源</h6>

<pre><code>@DELETE
@Path("{id}")
@Produces({ MediaType.TEXT_HTML })
public Response deletePodcastById(@PathParam("id") Long id) {
    podcastService.deletePodcastById(id);
    return Response.status(Response.Status.NO_CONTENT)// 204
            .entity("Podcast successfully removed from database").build();
}
</code></pre>

<p>注解</p>

<ul>
<li>@DELETE – 指示方法响应到 HTTP DELETE 请求</li>
<li>@PathParam("id")- 绑定传递的参数值</li>
<li>@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为"application/json"</li>
<li>@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为"text/html"</li>
</ul>


<p>响应</p>

<ul>
<li>成功: HTTP 状态 为 204 No Content</li>
<li>错误： 404 Not Found。如果资源不存在</li>
</ul>


<h2>4. 日志</h2>

<p>详见 <a href="http://www.codingpedia.org/ama/how-to-log-in-spring-with-slf4j-and-logback/">http://www.codingpedia.org/ama/how-to-log-in-spring-with-slf4j-and-logback/</a></p>

<h2>5. 异常处理</h2>

<p>错误处理要有统一的格式，就像下面</p>

<pre><code>{
   "status": 400,
   "code": 400,
   "message": "Provided data not sufficient for insertion",
   "link": "http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-with-jersey-and-spring",
   "developerMessage": "Please verify that the feed is properly generated/set"
}
</code></pre>

<h2>6. 服务端添加 CORS 支持</h2>

<h2>7. 测试</h2>

<h3>7.1. 在Java集成测试</h3>

<h3>7.1.1. 配置</h3>

<h5>7.1.1.1 Jersey 客户端依赖</h5>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
    &lt;version&gt;${jersey.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<h5>7.1.1.2. Failsafe 插件</h5>

<pre><code>&lt;plugins&gt;
    [...]
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.16&lt;/version&gt;
        &lt;executions&gt;
            &lt;execution&gt;
                &lt;id&gt;integration-test&lt;/id&gt;
                &lt;goals&gt;
                    &lt;goal&gt;integration-test&lt;/goal&gt;
                &lt;/goals&gt;
            &lt;/execution&gt;
            &lt;execution&gt;
                &lt;id&gt;verify&lt;/id&gt;
                &lt;goals&gt;
                    &lt;goal&gt;verify&lt;/goal&gt;
                &lt;/goals&gt;
            &lt;/execution&gt;
        &lt;/executions&gt;
    &lt;/plugin&gt;
    [...]
&lt;/plugins&gt;
</code></pre>

<h5>7.1.1.2. Jetty Maven 插件</h5>

<pre><code>&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
        &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;${jetty.version}&lt;/version&gt;
        &lt;configuration&gt;
            &lt;jettyConfig&gt;${project.basedir}/src/main/resources/config/jetty9.xml&lt;/jettyConfig&gt;
            &lt;stopKey&gt;STOP&lt;/stopKey&gt;
            &lt;stopPort&gt;9999&lt;/stopPort&gt;
            &lt;stopWait&gt;5&lt;/stopWait&gt;
            &lt;scanIntervalSeconds&gt;5&lt;/scanIntervalSeconds&gt;
        [...]
        &lt;/configuration&gt;
        &lt;executions&gt;
            &lt;execution&gt;
                &lt;id&gt;start-jetty&lt;/id&gt;
                &lt;phase&gt;pre-integration-test&lt;/phase&gt;
                &lt;goals&gt;
                    &lt;!-- stop any previous instance to free up the port --&gt;
                    &lt;goal&gt;stop&lt;/goal&gt;               
                    &lt;goal&gt;run-exploded&lt;/goal&gt;
                &lt;/goals&gt;
                &lt;configuration&gt;
                    &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;
                    &lt;daemon&gt;true&lt;/daemon&gt;
                &lt;/configuration&gt;
            &lt;/execution&gt;
            &lt;execution&gt;
                &lt;id&gt;stop-jetty&lt;/id&gt;
                &lt;phase&gt;post-integration-test&lt;/phase&gt;
                &lt;goals&gt;
                    &lt;goal&gt;stop&lt;/goal&gt;
                &lt;/goals&gt;
            &lt;/execution&gt;
        &lt;/executions&gt;
    &lt;/plugin&gt;
    [...]
&lt;/plugins&gt;
</code></pre>

<p>详细配置见源码中的 pom.xml</p>

<h4>7.1.2. 编译集成测试</h4>

<p>使用 JUnit  作为测试框架。默认的 Failsafe 插件 自动包含所有测试类</p>

<ul>
<li>"<em>*/IT</em>.java" – “IT”开头的文件.</li>
<li>"<em>*/</em>IT.java" – “IT”结尾的文件.</li>
<li>"<em>*/</em>ITCase.java" – “ITCase”结尾的文件.</li>
</ul>


<p>创建了测试类 RestDemoServiceIT</p>

<pre><code>public class RestDemoServiceIT {

    [....]
    @Test
    public void testGetPodcast() throws JsonGenerationException,
            JsonMappingException, IOException {

        ClientConfig clientConfig = new ClientConfig();
        clientConfig.register(JacksonFeature.class);

        Client client = ClientBuilder.newClient(clientConfig);

        WebTarget webTarget = client
                .target("http://localhost:8888/demo-rest-jersey-spring/podcasts/2");

        Builder request = webTarget.request(MediaType.APPLICATION_JSON);

        Response response = request.get();
        Assert.assertTrue(response.getStatus() == 200);

        Podcast podcast = response.readEntity(Podcast.class);

        ObjectMapper mapper = new ObjectMapper();
        System.out
                .print("Received podcast from database *************************** "
                        + mapper.writerWithDefaultPrettyPrinter()
                                .writeValueAsString(podcast));

    }
}
</code></pre>

<p>注意：</p>

<ul>
<li>在客户也要注册 JacksonFeature ，这样才能解析 JSON格式</li>
<li>用 jetty 测试，端口 8888</li>
<li>期望 返回 200 状态 给我们的请求</li>
<li>org.codehaus.jackson.map.ObjectMapper 帮助返回格式化的 JSON</li>
</ul>


<h4>7.1.3. 运行集成测试</h4>

<p>运行</p>

<pre><code>mvn verify
</code></pre>

<p>设置  <code>jetty.port</code> 属性到 8888,Eclipse  配置如下</p>

<p><img src="http://99btgc01.info/uploads/2014/11/run-integration-tests-eclipse.png" alt="" /></p>

<h3>7.2. 用 SoapUI 集成测试</h3>

<p><a href="http://www.youtube.com/watch?v=XV7WW0bDy9c">youtube视频教程</a>（需翻墙）</p>

<h2>8. 版本管理</h2>

<p>几个要点：</p>

<ul>
<li>URL:  “/v1/podcasts/{id}”</li>
<li>Accept/Content-type header: application/json; version=1</li>
</ul>


<p>在 路径中 加入 版本信息</p>

<pre><code>@Component
@Path("/v1/podcasts")
public class PodcastResource {...}
</code></pre>

<p>参考：</p>

<ul>
<li><a href="https://jersey.java.net/">https://jersey.java.net/</a></li>
<li><a href="https://github.com/waylau/Jersey-2.x-User-Guide">https://github.com/waylau/Jersey-2.x-User-Guide</a></li>
<li><a href="http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-in-java-with-jersey-and-spring/">http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-in-java-with-jersey-and-spring/</a></li>
</ul>


      <div class="readall"><a href="/jersey-2-spring-4-rest/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/vpn-setting/">设置 VPN,通过 VPN 翻墙科学上网</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年11月21日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#web">web</a>
      </p>
    </header>
    <div class="post-main">
      <p>之前介绍了《<a href="http://www.waylau.com/about-vpngate/">用 VPN Gate 翻墙科学上网</a>》,通过安装客户端，方便实现 VPN 的连接。如果 你爱折腾，也可以手动设置 VPN 。这样的连接 更加稳定。</p>

<h2>什么是VPN</h2>

<p>虚拟专用网(VPN)被定义为通过一个公用网络(通常是因特网)建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。虚拟专用网是对企业内部网的扩展。</p>

<h2>VPN 能做啥</h2>

<ul>
<li>连接公共 VPN 服务器获得自由访问互联网（翻墙）。</li>
<li>绕过您的本地故障防火墙的数据包拦截，并安全地隐藏你的 IP 地址。</li>
<li>安全加密网络信号。当你通过互联网发送信息时，保护您的隐私。</li>
</ul>


<h2>在 windows 上设置 VPN</h2>

<p>1.打开网络共享中心</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn001_zps9fa844e1.jpg" alt="" /></p>

<p>2.设置新连接</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn002_zps7054fdfe.jpg" alt="" /></p>

<p>3.选择 VPN连接</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn003_zps0af36d2d.jpg" alt="" /></p>

<p>4.建一个新的连接</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn004_zps368e912d.jpg" alt="" /></p>

<p>5.选择使用 VPN</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn005_zps0631dea5.jpg" alt="" /></p>

<p>6.输入 VPN 的 IP</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn006_zpsc9e05e36.jpg" alt="" /></p>

<p>7.输入 VPN  的账号、密码，最好就记住</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn007_zpsf1c75c9a.jpg" alt="" /></p>

<p>8.此时连接可以用了。可以马上连，也可以稍后连接</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn008_zpsb0c0b05e.jpg" alt="" /></p>

<p>9.VPN 连接已经创建，右键可以执行“连接”“断开”等操作</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn009_zps8af40472.jpg" alt="" /></p>

<h2>在 Android 上设置 VPN</h2>

<ol>
<li>初始配置 (只需在第一次时安装一次)</li>
</ol>


<p>从安卓启动 "Settings" 应用程序。
在 "Wireless &amp; Networks" 类别中，打开 "More..." 并点击 "VPN"。
点击 "Add VPN profile" 按钮来创建一个新的 VPN 连接。</p>

<p><img src="http://99btgc01.info/uploads/2014/11/001%2812%29.jpg" alt="" /></p>

<p>一个新的 VPN 连接设置编辑屏幕将出现。在 "Name" 字段输入一些字符串 (如 "vpn" ) ，并在 "Type" 字段选择类型，如 "L2TP/IPSec PSK" 。
在此屏幕上，你必须指定 VPN 主机名或 IP 地址。
复制 DDNS 主机名称 (以 ".opengw.net" 标识符结尾) 或 IP 地址 (位数如:xxx.xxx.xxx.xxx) 并粘贴它到配置屏幕的 "Server address" 字段。</p>

<p>一般情况下，建议指定 DDNS 主机名称 (以 ".opengw.net" 标识符结尾)。DDNS 主机名称可以继续使用，即使 DDNS 主机名对应的 IP 地址将来被改变。然而，在某些国家或地区，您可能无法使用 DDNS 主机名称。如果你不能指定 DDNS 主机名称，尝试使用 IP 地址 (位数如 xxx.xxx.xxx.xxx) 规格来代替。</p>

<p><img src="http://99btgc01.info/uploads/2014/11/002l.jpg" alt="" /></p>

<p>向下滚动配置屏幕，并点击 "Show advanced options" 复选框，如果合适的话。
在 "IPSec pre-shared key" 字段输入 vpn  的密码，
在 "Forwarding routes" 字段输入 "0.0.0.0/0" (9 个字母)。请确定你在 "Forwarding routes" 字段输入正确。如果不对，你不能通过 VPN 通信。
所有输完后，点击 "Save" 按钮并保存 VPN 连接设置。</p>

<p><img src="http://99btgc01.info/uploads/2014/11/002l.jpg" alt="" /></p>

<ol>
<li>连接 VPN</li>
</ol>


<p>在任何时候通过使用已创建的 VPN 连接设置，您可以开始一个 VPN 连接。打开 VPN 连接设置列表并点击设置，你将看到以下屏幕。</p>

<p><img src="http://99btgc01.info/uploads/2014/11/004%284%29.jpg" alt="" /></p>

<p>在第一次使用时，你必须输入"Username" 和 "Password" 字段。
然后选择 "Save account information"。
点击 "Connect" 开始 VPN 连接。</p>

<p><img src="http://99btgc01.info/uploads/2014/11/005%283%29.jpg" alt="" /></p>

<p>VPN 连接建立后，指示字符串 "Connected" 将显示在 VPN 连接设置旁，安卓的状态指示区将显示 "VPN activated" 消息。您可以点击消息看当前 VPN 连接状态。</p>

<ol>
<li>通过 VPN 中继享受互联网</li>
</ol>


<p>当 VPN 建立时，所有到互联网的通讯将通过 VPN 服务器转发。
如果你连接到一个位于海外国家的 VPN 服务器，当你的 VPN 连接建立时，享受 YouTube、Facebook 或 Twitter 吧。</p>

<p><img src="http://99btgc01.info/uploads/2014/11/006%283%29.jpg" alt="" /></p>

<h2>使用免费的 VPN</h2>

<p>这里提供可使用的免费的 VPN，<a href="https://github.com/waylau/free-vpn">https://github.com/waylau/free-vpn</a></p>

      <div class="readall"><a href="/vpn-setting/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/pla-big-slogan/">壮哉我军大字标语，亮瞎美帝的狗眼！</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年11月21日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#outdoor">outdoor</a>
      </p>
    </header>
    <div class="post-main">
      <p>茫茫大戈壁，随处可见的大字标语彰显我军的战斗精神！用美帝的谷歌卫星地图，清晰看到这一道道独特的风景。</p>

<p>用<a href="http://ditu.google.cn/maps?output=classic&amp;dg=ctry">谷歌地图</a>输入坐标即可</p>

<p>苦练精兵： 43°43 45.72 N, 87°40 12.59 E</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/82E67EC37CBE5175_zps9ae0a661.jpg" alt="" /></p>

<p>卫国戍边以卡为家： 45°22 3.47 N, 90°34 23.67 E</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/536B56FD_zpsa2da0d8b.jpg" alt="" /></p>

<p>严格要求严格训练： 45° 6 56.73 N, 82°31 32.44 E</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/4E25683C89816C42_zpsb27a5566.jpg" alt="" /></p>

<p>只争朝夕: 42 39 33.30 n,94 16 00.56 e</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/53EA4E89671D5915_zpsba4a4f63.jpg" alt="" /></p>

<p>为人民服务: 42 32 33.95 n,94 19 36.80 e</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/4E3A4EBA6C11_zpsd5944b53.jpg" alt="" /></p>

<p>毛主席万岁: 42 39 18.85 n,94 10 00.80 e</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/6BDB_zps9ac9f968.jpg" alt="" /></p>

<p>时刻准备打仗</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/65F6523B80FD6253_zps63eb9a60.jpg" alt="" /></p>

<p>其他</p>

<p>壮我大中华39 41 43.75,73 55 37.39</p>

<p>排除万难去争取胜利 42 27 12.08 n,94 08 49.36 e</p>

      <div class="readall"><a href="/pla-big-slogan/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/about-vpngate/">用 VPN Gate 翻墙科学上网</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年11月19日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#web">web</a>
      </p>
    </header>
    <div class="post-main">
      <h2>VPN Gate 综述</h2>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/vpn-top_zps08e8f3c2.jpg" alt="" /></p>

<p><a href="http://www.vpngate.net/">VPN Gate</a> 学术实验项目是一个在线服务，由日本国立筑波大学研究生院为学术研究目的运营。本研究的目的是推广 "全球分布式公共 VPN 中继服务器" 的知识。</p>

<h2>VPN Gate 公共 VPN 中继服务器</h2>

<p>在 VPN Gate 学术项目网站上有一个公共 VPN 中继服务器列表。互联网上的任何人都可以建立 VPN 连接至任一列表上的 VPN 服务器。无需用户注册。</p>

<h2>VPN Gate 公共 VPN 中继服务器的特点</h2>

<ul>
<li>VPN Gate 包括许多由世界各地的志愿者所提供的 VPN 服务器。
您可以提供自己的电脑作为一个 VPN 服务器加入到这个实验中。</li>
<li>Windows, Mac, iPhone, iPad 和安卓都可以连接到 VPN Gate 服务器。</li>
<li>支持 SSL-VPN (SoftEther VPN) 协议， L2TP/IPsec 协议， OpenVPN 协议和 Microsoft SSTP 协议。</li>
<li>接受匿名连接。无需用户注册。</li>
<li>每个 VPN 服务器的 IP 地址是不固定的。 IP 地址可能会不定期改变。</li>
<li>每天 VPN 服务器会有增加和减少。因此，所有 VPN 服务器不处于特定 IP 地址范围。</li>
<li>当一个 VPN 客户端连接到 VPN 服务器时， VPN 客户端可以通过那台 VPN 服务器访问互联网。您可以隐藏你的客户端的 IP 地址。</li>
<li>当您使用一个在物理上位于海外国家的 VPN 服务器，您的任何通信都被认为，好像是从该国发起的。然后你就可以通过使用 VPN Gate 访问网站了，这通常是无法从您所在的国家访问的。</li>
</ul>


<h2>想要解决的问题</h2>

<h3>存在的问题 1: 政府的防火墙有时未通过，一些海外网站变得遥不可及。</h3>

<p>某些国家的防火墙由于 "未知故障" 导致通信失败。例如，你在某一国家旅行，并尝试访问 YouTube， Twitter， Facebook 等网站，但却失败了。然而，你却可以访问到其他的海外网站，如雅虎等。</p>

<h3>存在的问题 2: 通过跟踪一个服务器访问日志的 IP 地址，可以确定一个人的隐私信息。</h3>

<p>如果您访问网站或发送电子邮件，你的源 IP 地址将被记录在目标 Web 服务器上，或在包含有电子邮件内容的包头里。</p>

<p>一个 IP 地址不仅仅是个人信息。然而， IP 地址可以被用来跟踪在各个网站产生活动的个人。这种跟踪技术常被用于垃圾邮件或强制广告中。</p>

<p>此外，通过法律的强制执行程序，一个 IP 地址可以被用来确定谁是发起相关通信的人。警察、检察官或律师可以使用其特权要求互联网服务供应商主持的 IP 地址分配的日志文件。在平常的时候，这样的 IP 地址分配日志通常由互联网服务供应商附上。然而，一旦有人获得日志，他可以调查谁发送了电子邮件、或谁发布到网站上一条消息。</p>

<p>此外，在互联网上，一个人在特定时间被分配了一个特定 IP 地址的人将被视为与在同一时间从此 IP 地址发起的任何非法通信有责任。最近在日本，执法者的可耻事件做为严重的问题被批评，执法人员错误地逮捕了从来没有在他的电脑上进行非法事情的无辜互联网用户，而是电脑感染了木马，被真正的犯人远程控制。真正的犯人让无辜的互联网用户的计算机发送敲诈邮件给一些公司，无辜的人被执法人员不公正地逮捕。无辜的人最终被释放，但这是在日本近代历史上最糟糕的诬告事件之一。</p>

<p>因此，当你访问互联网时，最好有一个方法来暂时隐藏你的真实 IP 地址。如果你的真实 IP 地址被隐藏，没有广告目的的 IP 地址的追踪将是不成功的。IP 地址可追溯性的风险将会降低。如果隐藏你的真实 IP 地址连接到互联网时，即使你的电脑感染了木马或恶意软件，错误逮捕的风险将永远不会给你。</p>

<h3>存在的问题 3: 公共 Wi-Fi 存在数据包被窃听的风险</h3>

<p>大多数公共 Wi-Fi 可以被人窃听。您的明文通信是不安全的。有线网络也有被窃听的风险。ARP 电子欺骗攻击者可以获取你的数据包。此外，网络管理员或提供公共 Wi-Fi 的咖啡馆或机场的设施业主可以随时窃听您的通信。即使你在家使用互联网，也有风险，您的 ISP 或电信公司的雇员可能窃听，在线路上偷看您的明文数据包。(事实上，有一个犯罪事件，日本电报电话公司的雇员，在电信大楼进行了窃听。所以，我们永远不能信任 ISP 或电信公司的员工)。</p>

<p>当在互联网上使用 HTTP、POP3 或 IMAP 纯文本通信时，你无法避免窃听。SSL (HTTPS) 对窃听是安全的，但是大多数网站使用的是 HTTP。HTTP 数据包传输的是纯文本格式。</p>

<p>最好的是存在这样的方法，对所有到互联网服务器的通信进行自动加密。在这种情况下，没有人可以在本地网络或本地电信大楼偷看你的数据包的内容。</p>

<h2>VPN 可以加密和转播你的通信</h2>

<p>如果你在使用互联网时使用 VPN ，可以解决上述这三个问题。</p>

<h3>解决方案 1: VPN 可以绕过防火墙。</h3>

<p>由于某些政府防火墙发生的 "未知故障" ，一些海外网站从防火墙后面无法访问，你可以通过海外的 VPN 服务器访问这些网站。海外 VPN 服务器将会把你的通信转到目标 Web 服务器。</p>

<h3>解决方案 2: VPN 可以隐藏你的真实 IP 地址。</h3>

<p>当 VPN 连接建立时，所有的通信的源 IP 地址将被替换为中继 VPN 服务器的 IP 地址。这将对你非常有帮助，因为在那一刻没有人再可以轻松地分析和跟踪你的真实 IP 地址了。目标 Web 服务器或 E-mail 的邮件头列表上的 IP 地址日志将被记录，好像通信是通过中继 VPN 服务器发起的。您可以安全地隐藏你的 IP 地址，并且可以发送匿名帖子或电子邮件到网站或邮件服务器。此外，如果您的计算机感染了由 "真正的罪犯" 发送的木马，真正的罪犯发送一个远程操作，让您的电脑发送非法敲诈邮件给某人，你不再处于被执法者错误逮捕的风险中。</p>

<h3>解决方案 3: VPN 可以防止在本地网络上的窃听</h3>

<p>如果你总是使用 VPN ，所有通信都将被自动加密。即使你的邻居在本地网络上是个搭线窃听者，你的数据包也不能被他偷看到。</p>

<h2>VPN Gate 和现有 VPN 服务之间有什么不同 ?</h2>

<p>如上所述， VPN 可以解决使用互联网中的几个问题。但是，通常你在远程地点 (海外) 至少需要一台物理的 VPN 服务器，实际利用上述 VPN 的功能。</p>

<p>大多数互联网用户都无法在海外拥有自己的 VPN 服务器。对于这样的用户，一些互联网公司提供了现有的、付费的、共享的 VPN 服务。这样的服务需要用户注册，用信用卡付款，将可以为用户创建一个帐户。用户将获得根据合同的具体条款使用共享 VPN 服务器的权利。</p>

<p>所以，什么是 VPN Gate 和现有的支付 VPN 服务之间的不同呢 ? 以用户的观点出发，两个似乎是相似的。但是， VPN Gate 与现有的 VPN 服务的差异描述如下。</p>

<h3>现有共享 VPN 服务的问题</h3>

<p>现有的 VPN 服务的实施，是供应商公司在数据中心托管的一些 VPN 服务器。在数据中心提供一些共享的 VPN 服务器的这种传统方法有一个问题，即每个 VPN 服务器的 IP 地址都在相同或相似的 IP 地址分配块。因为 IP 地址通常由相同的 ISP 分配。每个 VPN 服务器的 IP 地址是固定的，所以他们很少改变。</p>

<p>这种共享的 VPN 服务不容忍对 "政府防火墙的未知故障" 。 "政府防火墙的未知故障" ，通常会出现一系列 IP 地址块变成完全无法从该国境内访问的情况。如果 "未知故障" 发生在包含共享的 VPN 服务器群集的 IP 地址块分配的 IP 地址范围，没有群集的 VPN 服务器将无法从该国访问。事实上，最近有报道说，某天一个现有的共享 VPN 服务器的、特定的群集，从一个特定国家的政府防火墙突然无法访问。</p>

<p>现有共享 VPN 服务的另一个问题是: 带宽占用。现有的共享 VPN 服务器物理放置在特定的数据中心。每个用户的所有通信将集中在数据中心的上行线路的互联网传输线上。所有处理的工作量将集中在数据中心托管的一些共享 VPN 物理服务器上。服务提供商认为在集群中增加 VPN 服务器的数量，或增加互联网传输线路的带宽，但这种扩张需要成本。如果成本增加，这种共享的 VPN 服务的费用将会增加。如果节省成本，这种共享的 VPN 服务的速度将下降。大多数共享的 VPN 服务不能向用户提供优等质量。</p>

<h3>VPN Gate 学术实验的优点</h3>

<p>正如你可以看到 VPN Gate 公共 VPN 中继服务器的列表，有很多运行在 VPN Gate 公共 VPN 中继服务器。这些 VPN 服务器没有物理地放置在一个特定的数据中心，也没有一个特定的 IP 地址分配块，他们都是由不同 ISP、在物理地点托管的。</p>

<p>每个 VPN Gate 公共 VPN 中继服务器是分布式的，并由许多志愿者托管。一名志愿者是拥有一台计算机、保持带宽连接到互联网的人。他是一个同意提供 CPU 时间和带宽、支持 VPN Gate 学术实验的人。你可以成为一名志愿者。</p>

<p>志愿者在地理上是分布式的。志愿者的 ISP 也是分布式的。所以每一个 VPN 服务器的 IP 地址是分布式的。分配的 IP 地址没有特点。每天志愿者的数量增加或减少，每个 IP 地址每次都改变。如果政府的防火墙出现 "故障" ，整个 VPN Gate 中继服务器不受影响。如果一些 VPN 服务器无法从你的国家访问，你仍然可以访问其他 VPN 服务器。</p>

<p>因为 VPN Gate 服务器由志愿者托管，每个志愿者花费极少量的带宽成本和 CPU 时间在他的 VPN 服务器上， VPN Gate 服务可以被大家免费使用。免费的意思为任何想要使用 VPN Gate 服务的用户无需注册。</p>

<p>因此，不同于现有的共享 VPN 服务， VPN Gate 学术实验服务可以无需付费地使用。</p>

<h3>VPN Gate 网站的镜像服务器</h3>

<p>一旦一个用户连接 VPN 会话到 VPN Gate 公共 VPN 中继服务器之一，他可以从任何国家获得自由访问互联网。</p>

<p>然而，如果 www.vpngate.net 网站 (本网站) 无法从他的国家访问，他不能首先获得 VPN Gate 公共 VPN 中继服务器列表。</p>

<p>所以，我们提供了许多镜像站点的 URL <a href="https://github.com/waylau/vpngate-mirrors">https://github.com/waylau/vpngate-mirrors</a> ，以帮助在这些国家的用户。如果一个用户能获得访问至少一个镜像网站，他可以浏览 VPN Gate 公共 VPN 中继服务器列表页。</p>

<h2>VPN Gate client 客户端的使用</h2>

<p>VPN 在 Windows 上的分步指南 (使用 SoftEther VPN)</p>

<h3>1.安装带 VPN Gate Client 插件的 SoftEther VPN Client (只需在第一次时安装一次)</h3>

<p>下载带有 "VPN Gate Client 插件" 的 SoftEther VPN Client 的特殊版本。
<a href="https://github.com/waylau/vpngate-mirrors/">下载 SoftEther VPN Client + VPN Gate Client 插件</a></p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/01_zpse001e011.jpg" alt="down" /></p>

<p>解压缩下载的 ZIP 文件内容到一个文件夹中。如上图，安装程序和一些 DLL 文件被提取。
执行以 "vpngate-client" 开头的文件名的安装程序，并继续进行安装。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/02_zps419f7ea5.jpg" alt="" /></p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/03_zps378a9128.jpg" alt="" /></p>

<p>上述安装程序将启动。你必须在 "选择软件组件安装" 屏幕中选择 "SoftEther VPN Client" 。
安装完成后，将在桌面上创建 SoftEther VPN Client 的图标。</p>

<h3>2.运行 VPN Gate Client 插件并连接到 VPN Gate 服务器</h3>

<p>在桌面上双击 SoftEther VPN Client 图标。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/04_zpsd1aa9902.jpg" alt="" /></p>

<p>如上图， "VPN Gate 公共 VPN 中继服务器" 图标会显示在窗口中。双击该图标。
如果有通知显示，继续按屏幕描述的进行。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/05_zps3a635181.jpg" alt="" /></p>

<p>"SoftEther VPN Client 的 VPN Gate 学术实验项目插件" 启动。
在此屏幕上，你可以看到当前正在运行的 VPN Gate 公共 VPN 服务器的列表。此屏幕上的列表与 顶页的列表 是相同的。从列表中选择一个连接，然后单击 "连接到 VPN 服务器" 按钮。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/06_zps7a3c07be.jpg" alt="" /></p>

<p>如果选定的 VPN Gate 服务器同时支持 TCP 和 UDP 协议，上面的屏幕将会出现。在屏幕上选择 TCP 或 UDP。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/07_zpsdde12094.jpg" alt="" /></p>

<p>如果一个 VPN 连接建立成功了，上面的消息将出现。这个窗口将在 5 秒后自动消失。如果您无法连接到指定的 VPN 服务器，再试一次。</p>

<h3>3.通过 VPN 中继享受互联网</h3>

<p>虽然建立了 VPN 连接，在 Windows 上将创建一个虚拟网络适配器，该适配器将被分配一个以 "10.211" 开始的 IP 地址。默认网关地址将被指定在虚拟网络适配器上。您可以在 Windows 命令提示下运行 "ipconfig / all" 命令，确认这些网络配置。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/08_zpsb6bd618c.jpg" alt="" /></p>

<p>当 VPN 建立时，所有到互联网的通讯将通过 VPN 服务器转发。您可以在 Windows 命令提示中使用 "tracert 8.8.8.8" 命令验证。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/09_zps19a95efa.jpg" alt="" /></p>

<p>如上图，如果数据包路径是通过 "10.211.254.254" ，你的通信现在就是通过 VPN Gate 公共 VPN 服务器中的一个转发的。
您还可以访问 VPN Gate 顶部页面 来查看当前的全球 IP 地址。如果你连接到一个位于海外国家的 VPN 服务器，您可以看到您的来源国或地区已更改为其他的。</p>

<p><img src="http://i1288.photobucket.com/albums/b484/waylau/10_zps3b2c9346.jpg" alt="" /></p>

<p>当你的 VPN 连接建立时，享受 YouTube、Facebook 或 Twitter 吧。
Facebook、Twitter 和 Gmail 使用 HTTPS (SSL) 加密的通信协议。无论是否通过 VPN ，没有人可以窃听这些加密通信。</p>

      <div class="readall"><a href="/about-vpngate/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/chinese-administrative-division/">中国行政区划的英文</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年11月18日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#english">english</a>
      </p>
    </header>
    <div class="post-main">
      <h2>中国行政区划（administrative division）</h2>

<p>分为几个级别（government level/level）；宪法（Constitution）规定了三个级别（de jure level），但实际上有五个级别（de facto level/practical level）——33个省级（province/province-level region/province-level division）、333个地区级（prefecture/prefecture-level region/prefecture-level division/second-level division）【非宪法区划】、2862个县级（county/county-level region/county-level division）、41636个乡级（township/township-level region/township-level division）及无数村级（village/village-level region/village-level division）【非宪法区划】行政区。各个级别又有不同名称，下面加以详细讨论【具体数字以2005年统计数据为准】。</p>

<h2>省级行政区</h2>

<ul>
<li>22个省（province）【台湾省也可以叫‘据称’的省份，claimed province】</li>
<li>五个自治区（autonomous region）</li>
<li>四个直辖市（municipality/centrally-administered municipality）</li>
<li>两个特别行政区（special administrative region/SAR）【香港（Hong Kong）与澳门（Macau/Macao）】</li>
<li>直属（subservient to）中央政府（central government）。省长叫governor。</li>
</ul>


<h2>地区级行政区</h2>

<ul>
<li>17个地区（prefecture）</li>
<li>30个自治州（autonomous prefecture）【少数民族叫ethnic minority）】</li>
<li>283个地级市（prefecture-level city）</li>
<li>三个盟（league）。</li>
</ul>


<h2>县级行政区具</h2>

<ul>
<li>1464个县（county）</li>
<li>117个自治县（autonomous county）</li>
<li>374个县级市（county-level  city）</li>
<li>852个市辖区（district）</li>
<li>49个旗（banner）</li>
<li>三个自治旗（autonomous banner）</li>
<li>一个林区（forestry area）</li>
<li>两个特区（special district）。</li>
</ul>


<h2>乡级行政区</h2>

<ul>
<li>14677个乡（township）</li>
<li>1092个民族乡（ethnic township）</li>
<li>19522个镇（town）</li>
<li>6152个街道办事处（subdistrict）</li>
<li>11个区公所（district public office）</li>
<li>181个苏木（sumu）</li>
<li>一个民族苏木（ethnic sumu）。</li>
</ul>


<h2>村级行政区</h2>

<ul>
<li>80717个社区居民委员会（neighborhood committee）【社区叫neighborhood或community）】</li>
<li>623669个村民委员会（village committee）或村民小组（village group）【包括行政村（administrative village）和自然村（natural village）】。</li>
</ul>


<h2>特殊情况</h2>

<ul>
<li>副省级城市（sub-provincial city）</li>
<li>副地级市（sub-prefecture-level city）</li>
<li>副省级城市辖区（sub-provincial district）【如上海的浦东和天津的滨海】。</li>
</ul>


<h2>其他</h2>

<p>中国又可以分为几个大区，但不是严格的行政区划：</p>

<ul>
<li>华东（East China）</li>
<li>东北（Northeast China）</li>
<li>华北（North China）</li>
<li>中南（South Central China）</li>
<li>华中（Central China）</li>
<li>华南（Southern China/South China）</li>
<li>西部（Western China）</li>
<li>西北（Northwest China）</li>
<li>西南（Southwest China）</li>
</ul>


<p><em>参考：</em><a href="http://www.24en.com/column/Khubilai/2010-08-31/119131.html">http://www.24en.com/column/Khubilai/2010-08-31/119131.html</a></p>

      <div class="readall"><a href="/chinese-administrative-division/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/go-websocket-chat/">WebSocket 和 Golang 实现聊天功能</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年11月17日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#golang">golang</a>
      </p>
    </header>
    <div class="post-main">
      <p>这个示例应用程序展示了如何使用 <a href="http://tools.ietf.org/html/rfc6455">WebSocket</a>, <a href="http://golang.org/">Golang</a> 和  <a href="http://jquery.com/">jQuery</a> 创建一个简单的web聊天应用程序。这个示例的源代码在 <a href="https://github.com/waylau/goChat">https://github.com/waylau/goChat</a> 。</p>

<h2>Running the example 运行示例</h2>

<p>这个示例需要 Golang 开发环境。 该<a href="http://golang.org/doc/install.html">页面</a>描述如何安装开发环境。</p>

<p>一旦你去启动和运行,您可以下载、构建和运行的例子, 使用命令:</p>

<pre><code>go get gary.burd.info/go-websocket-chat
go-websocket-chat
</code></pre>

<p>在支持 websocket 的浏览器尝试打开 <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> 启动应用</p>

<h2>Server 服务器</h2>

<p>服务器程序实现了 <a href="http://golang.org/pkg/net/http/">http</a> 包，包含了 Go 分发和 Gorilla 项目的 websocket 包.</p>

<p>应用程序定义了两种类型, connection 和 hub 。服务器为每个 webscocket 连接 创建的一个 connection 类型的实例 。 连接器扮演了 websocket 和 hub 类型单例 之间的媒介 。 hub 保持一组注册了的连接器 和 广播到连接器的信息。</p>

<p>程序运行了一个 goroutine 给 hub ,两个 goroutine 给每个连接器。 goroutine 通过 channel 和其他进行交流。 hub 拥有注册连接器、注销连接器和广播信息的 channel。一个连机器拥有缓存的发出信息的 channel 。其中一个 连接器的 goroutine 从这个 channel 中读信息 并把信息写入 webscoket。另外一个连接器 goroutine 从 websocket  读信息，并把信息发送到 hub。</p>

<p>下面是 hub 类型代码：</p>

<pre><code>package main

type hub struct {
    // 注册了的连接器
    connections map[*connection]bool

    // 从连接器中发入的信息
    broadcast chan []byte

    // 从连接器中注册请求
    register chan *connection

    // 从连接器中注销请求
    unregister chan *connection
}

var h = hub{
    broadcast:   make(chan []byte),
    register:    make(chan *connection),
    unregister:  make(chan *connection),
    connections: make(map[*connection]bool),
}

func (h *hub) run() {
    for {
        select {
        case c := &lt;-h.register:
            h.connections[c] = true
        case c := &lt;-h.unregister:
            if _, ok := h.connections[c]; ok {
                delete(h.connections, c)
                close(c.send)
            }
        case m := &lt;-h.broadcast:
            for c := range h.connections {
                select {
                case c.send &lt;- m:
                default:
                    delete(h.connections, c)
                    close(c.send)
                }
            }
        }
    }
}
</code></pre>

<p>应用程序的 主要 函数启动 hub 以 goroutine 形式运行方法。连接器 发送请求到 hub 通过 注册、注销和广播 channel。</p>

<p>hub 注册连接器通过添加 connection 的指针作为 connections map 的主键。这个  map 的值通常是 true。</p>

<p>注销的代码有点复杂。除了从 connections map 删除连接器的指针外,  hub 关闭了 connection 的发送，来标识没有信息再被发送到 connection了。</p>

<p>hub 通过循环注册连接器和发送信息到连接器的发送 channel 来控制信息。 如果连接器的发送缓冲区已经满了，那么  hub 假设 客户端已死或卡住了。这种情况下, hub 注销连接器 并关闭 websocket.</p>

<p>下面关于 connection 类型的代码：</p>

<pre><code>package main

import (
    "github.com/gorilla/websocket"
    "net/http"
)

type connection struct {
    // websocket 连接器
    ws *websocket.Conn

    // 发送信息的缓冲 channel 
    send chan []byte
}

func (c *connection) reader() {
    for {
        _, message, err := c.ws.ReadMessage()
        if err != nil {
            break
        }
        h.broadcast &lt;- message
    }
    c.ws.Close()
}

func (c *connection) writer() {
    for message := range c.send {
        err := c.ws.WriteMessage(websocket.TextMessage, message)
        if err != nil {
            break
        }
    }
    c.ws.Close()
}

var upgrader = &amp;websocket.Upgrader{ReadBufferSize: 1024, WriteBufferSize: 1024}

func wsHandler(w http.ResponseWriter, r *http.Request) {
    ws, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        return
    }
    c := &amp;connection{send: make(chan []byte, 256), ws: ws}
    h.register &lt;- c
    defer func() { h.unregister &lt;- c }()
    go c.writer()
    c.reader()
}
</code></pre>

<p>wsHandler 方法被主函数当做<a href="http://golang.org/pkg/net/http/#Handler">http handler</a>注册。HTTP 连接到 WebSocket 协议的升级，创建一个连接对象，注册这个连接到 sub ,并通过 <a href="http://weekly.golang.org/doc/effective_go.html#defer">defer</a>延迟语句 来控制 连接的注销。</p>

<p>接着，wsHandler 方法开启 连接器的写入方法作为一个 goroutine。 写入方法将信息从连接器的 channel 转入 websocket。当 hub 关闭 channel 或者 在写入 websocket 时出错，写入方法关闭。</p>

<p>最后，wsHandler 方法 调用连接器的 读 方法。 读方法将 入站消息 从 websocket 转到 hub。</p>

<p>这里是服务器的代码的其余部分:</p>

<pre><code>package main

import (
    "flag"
    "go/build"
    "log"
    "net/http"
    "path/filepath"
    "text/template"
)

var (
    addr      = flag.String("addr", ":8080", "http service address")
    assets    = flag.String("assets", defaultAssetPath(), "path to assets")
    homeTempl *template.Template
)

func defaultAssetPath() string {
    p, err := build.Default.Import("gary.burd.info/go-websocket-chat", "", build.FindOnly)
    if err != nil {
        return "."
    }
    return p.Dir
}

func homeHandler(c http.ResponseWriter, req *http.Request) {
    homeTempl.Execute(c, req.Host)
}

func main() {
    flag.Parse()
    homeTempl = template.Must(template.ParseFiles(filepath.Join(*assets, "home.html")))
    go h.run()
    http.HandleFunc("/", homeHandler)
    http.HandleFunc("/ws", wsHandler)
    if err := http.ListenAndServe(*addr, nil); err != nil {
        log.Fatal("ListenAndServe:", err)
    }
}
</code></pre>

<p>应用主程序启动 hub goroutine。 接着 主程序 注册 主页 和 websocket 连接器的控制器N。最后主程序启动 HTTP 服务器。</p>

<h2>Client 客户端</h2>

<p>客户端的实现是一个简单的 HTML 文件：</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Chat Example&lt;/title&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    $(function() {

    var conn;
    var msg = $("#msg");
    var log = $("#log");

    function appendLog(msg) {
        var d = log[0]
        var doScroll = d.scrollTop == d.scrollHeight - d.clientHeight;
        msg.appendTo(log)
        if (doScroll) {
            d.scrollTop = d.scrollHeight - d.clientHeight;
        }
    }

    $("#form").submit(function() {
        if (!conn) {
            return false;
        }
        if (!msg.val()) {
            return false;
        }
        conn.send(msg.val());
        msg.val("");
        return false
    });

    if (window["WebSocket"]) {
        conn = new WebSocket("ws:///ws");
        conn.onclose = function(evt) {
            appendLog($("&lt;div&gt;&lt;b&gt;Connection closed.&lt;/b&gt;&lt;/div&gt;"))
        }
        conn.onmessage = function(evt) {
            appendLog($("&lt;div/&gt;").text(evt.data))
        }
    } else {
        appendLog($("&lt;div&gt;&lt;b&gt;Your browser does not support WebSockets.&lt;/b&gt;&lt;/div&gt;"))
    }
    });
&lt;/script&gt;
&lt;style type="text/css"&gt;
html {
    overflow: hidden;
}

body {
    overflow: hidden;
    padding: 0;
    margin: 0;
    width: 100%;
    height: 100%;
    background: gray;
}

#log {
    background: white;
    margin: 0;
    padding: 0.5em 0.5em 0.5em 0.5em;
    position: absolute;
    top: 0.5em;
    left: 0.5em;
    right: 0.5em;
    bottom: 3em;
    overflow: auto;
}

#form {
    padding: 0 0.5em 0 0.5em;
    margin: 0;
    position: absolute;
    bottom: 1em;
    left: 0px;
    width: 100%;
    overflow: hidden;
}

&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="log"&gt;&lt;/div&gt;
&lt;form id="form"&gt;
    &lt;input type="submit" value="Send" /&gt;
    &lt;input type="text" id="msg" size="64"/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>客户端使用 <a href="http://jquery.com/">jQuery</a></p>

<p>文档加载。脚本检查 websocket 的功能 。如果 WebSocket 功能 可以用，然后打开脚本与服务器的连接，并注册一个回调处理来自服务器的信息。回调使用 appendlog 方法将消息添加到聊天记录。</p>

<p>appendlog 方法检查在添加新的内容时的滚动位置，从而可以让用户手动滚动聊天记录而不会被新来的消息中断。如果聊天记录滚动至底部，那么新内容添加的到旧内容的后面。否则，滚动的位置不会改变。</p>

<p>表单处理器将用户的输入写入到 WebSocket 并且清除输入字段。</p>

<p><em>参考：</em><a href="http://gary.burd.info/go-websocket-chat">http://gary.burd.info/go-websocket-chat</a></p>

      <div class="readall"><a href="/go-websocket-chat/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="pagination">
  
  <span class="pagination-item newer"><i class="fa fa-arrow-left"></i>&nbsp;&nbsp;上一页</span>
    

    
      <span class="current-page">1</span>
      

    
      
      <a href="/page/2">2</a>
      
    
      
      <a href="/page/3">3</a>
      
    
      
      <a href="/page/4">4</a>
      
    
      
      <a href="/page/5">5</a>
      
    
      
      <a href="/page/6">6</a>
      
    
      
      <a href="/page/7">7</a>
      
    
      
      <a href="/page/8">8</a>
      
    
      
      <a href="/page/9">9</a>
      
    
      
      <a href="/page/10">10</a>
      
    
      
      <a href="/page/11">11</a>
      
    
      
      <a href="/page/12">12</a>
      
    
      
      <a href="/page/13">13</a>
      
    
      
      <a href="/page/14">14</a>
      
    
      
      <a href="/page/15">15</a>
      
    
      
      <a href="/page/16">16</a>
      
    
      
      <a href="/page/17">17</a>
      
    
      
      <a href="/page/18">18</a>
      
    
      
      <a href="/page/19">19</a>
      
    
      
      <a href="/page/20">20</a>
      
    
      
      <a href="/page/21">21</a>
      
    
      
      <a href="/page/22">22</a>
      
    
  (共129篇)

  
  <a class="pagination-item older" href="/page/2">下一页&nbsp;&nbsp;<i class="fa fa-arrow-right"></i></a>
  
</div>

    <footer>Copyright&nbsp;&copy;&nbsp;2014 <a href="http://www.waylau.com">Way Lau's Blog</a><br/><i class="fa fa-cogs" style="color:blueviolet;">&nbsp;</i>Powered by <a href="https://github.com/waylau/jekyll-theme-blog" target="_blank">jekyll-theme-blog</a></footer>
    </div>


  </div>    
  <div id="top"><a id="rocket" href="javascript:;" title="返回顶部"><i></i></a></div>
  


</body>
</html>