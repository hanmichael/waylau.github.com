<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RSS - Way Lau's Blog</title>
    <description>Way Lau's Blog - 技术改变世界！</description>
    <link>http://www.waylau.com</link>
    <atom:link href="http://www.waylau.com/page/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 26 Nov 2014 17:58:53 +0800</pubDate>
    <lastBuildDate>Wed, 26 Nov 2014 17:58:53 +0800</lastBuildDate>
    <generator>Way Lau</generator>
    
      <item>
        <title>用 Jersey 2 和 Spring 4 构建 RESTful web service</title>
        <description>&lt;p&gt;本文介绍了如何通过 Jersey 框架优美的在 Java 实现了 REST 的 API。CRUD 的 操作存储在 MySQL 中&lt;/p&gt;

&lt;h2&gt;1. 示例&lt;/h2&gt;

&lt;h3&gt;1.1 为什么&lt;/h3&gt;

&lt;p&gt;Spring 可以对于 REST 有自己的实现(见 &lt;a href=&quot;https://spring.io/guides/tutorials/rest/&quot;&gt;https://spring.io/guides/tutorials/rest/&lt;/a&gt;)。 但本文展示的是用 “官方” 的 方法来实现 REST ，即使用 Jersey。&lt;/p&gt;

&lt;h3&gt;1.2 它是做什么的?&lt;/h3&gt;

&lt;p&gt;管理 资源。 REST API 将允许创建、检索、更新和删除这样的资源。&lt;/p&gt;

&lt;h3&gt;1.3 架构及技术&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/Rest-Demo-Diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本示例项目使用多层结构，基于“Law of Demeter (LoD) or principle of least knowledge”（迪米特法则），是说一个软件实体要尽可能的只与和它最近的实体进行通讯。通常被表述为：talk only to your immediate friends ( 只和离你最近的朋友进行交互)。&lt;br/&gt;
 “talk”，其实就是对象间方法的调用。这条规则表明了对象间方法调用的原则：（1）调用对象本身的方法；（2）调用通过参数传入的对象的方法；（3）在方法中创建的对象的方法；（4）所包含对象的方法。&lt;/p&gt;

&lt;p&gt;主要分为三层：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一层：Jersey 实现对 REST 的支持，拥有 &lt;a href=&quot;http://en.wikipedia.org/wiki/Facade_pattern&quot;&gt;外观模式&lt;/a&gt;的角色并代理到逻辑业务层&lt;/li&gt;
&lt;li&gt;业务层: 发生逻辑的地方&lt;/li&gt;
&lt;li&gt;数据访问层： 是与持久数据存储（在我们的例子中是 MySql数据库)交互的地方&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;简述下技术框架：&lt;/p&gt;

&lt;h4&gt;1.3.1. Jersey (外观)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://jersey.java.net/&quot;&gt;Jersey&lt;/a&gt; 是开源、拥有产品级别的质量，提供构建  RESTful Web Services,支持  JAX-RS APIs ，提供 &lt;a href=&quot;https://jax-rs-spec.java.net/&quot;&gt;JAX-RS&lt;/a&gt; (JSR 311 &amp;amp; JSR 339) 参考实现。&lt;/p&gt;

&lt;h4&gt;1.3.2. Spring (业务层)&lt;/h4&gt;

&lt;p&gt;在我看来没有什么 比 &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot;&gt;Spring&lt;/a&gt; 更好的办法让 pojo 具有不同的功能。 你会发现在本教程用 Jersey 2 和 Spring 4 构建 RESTful web service&lt;/p&gt;

&lt;h4&gt;1.3.3. JPA 2 / Hibernate (持久层)&lt;/h4&gt;

&lt;p&gt;使用 Hibernate 实现 DAO 模式。&lt;/p&gt;

&lt;h4&gt;1.3.4. Web 容器&lt;/h4&gt;

&lt;p&gt;用 Maven 打包成 .war 文件开源部署在任意容器。一般用 &lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;Tomcat&lt;/a&gt; 和 &lt;a href=&quot;http://www.eclipse.org/jetty/&quot;&gt;Jetty&lt;/a&gt; ，也可以是 Glassfih, Weblogic, JBoss 或 WebSphere.&lt;/p&gt;

&lt;h4&gt;1.3.5. MySQL 数据库&lt;/h4&gt;

&lt;p&gt;示例数据存储在一个 MySQL 表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/database-schema.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;1.3.6. 技术版本&lt;/h4&gt;

&lt;p&gt;Jersey 2.9&lt;/p&gt;

&lt;p&gt;Spring 4.0.3&lt;/p&gt;

&lt;p&gt;Hibernate 4&lt;/p&gt;

&lt;p&gt;Maven 3&lt;/p&gt;

&lt;p&gt;Tomcat 7&lt;/p&gt;

&lt;p&gt;Jetty 9&lt;/p&gt;

&lt;p&gt;MySql 5.6&lt;/p&gt;

&lt;h3&gt;1.4. 源码&lt;/h3&gt;

&lt;p&gt;见&lt;a href=&quot;https://github.com/waylau/RestDemo/tree/master/jersey-2-spring-4-rest&quot;&gt;https://github.com/waylau/RestDemo/tree/master/jersey-2-spring-4-rest&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2. 配置&lt;/h2&gt;

&lt;p&gt;开始呈现 REST API 的设计和实现之前,我们需要做一些配置。&lt;/p&gt;

&lt;h3&gt;2.1. 项目依赖&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/waylau/Jersey-2.x-User-Guide/tree/master/Chapter%2022.%20Spring%20DI%20%E4%BD%BF%E7%94%A8%20Spring%20%E6%B3%A8%E5%85%A5&quot;&gt;Jersey Spring 扩展包&lt;/a&gt; 是必须要放在 项目 classpath 中。在 pom.xml 中添加下面依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.glassfish.jersey.ext&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jersey-spring3&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${jersey.version}&amp;lt;/version&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;            
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;            
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jersey-media-json-jackson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.4.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;注意: jersey-spring3.jar 使用的是他自己的 Spring 库版本，所以如果你想使用自己的 (本例是使用 Spring 4.0.3.Release),你需要将这些库手动的移除。如果想看到其他 的库的依赖，请查看项目源码中的 pom.xml&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;2.2. web.xml&lt;/h3&gt;

&lt;p&gt;应用部署描述&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app version=&quot;3.0&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&amp;gt;
    &amp;lt;display-name&amp;gt;Demo - Restful Web Application&amp;lt;/display-name&amp;gt;

    &amp;lt;listener&amp;gt;
        &amp;lt;listener-class&amp;gt;
            org.springframework.web.context.ContextLoaderListener
        &amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;

    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:spring/applicationContext.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;jersey-serlvet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;
            org.glassfish.jersey.servlet.ServletContainer
        &amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;javax.ws.rs.Application&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;org.codingpedia.demo.rest.RestDemoJaxRsApplication&amp;lt;/param-value&amp;gt;            
        &amp;lt;/init-param&amp;gt;        
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;jersey-serlvet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

    &amp;lt;resource-ref&amp;gt;
        &amp;lt;description&amp;gt;Database resource rest demo web application &amp;lt;/description&amp;gt;
        &amp;lt;res-ref-name&amp;gt;jdbc/restDemoDB&amp;lt;/res-ref-name&amp;gt;
        &amp;lt;res-type&amp;gt;javax.sql.DataSource&amp;lt;/res-type&amp;gt;
        &amp;lt;res-auth&amp;gt;Container&amp;lt;/res-auth&amp;gt;
    &amp;lt;/resource-ref&amp;gt;    
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.2.1. Jersey-servlet&lt;/h4&gt;

&lt;p&gt;注意 Jersey servlet 的配置，&lt;code&gt;javax.ws.rs.core.Application&lt;/code&gt; 类定义了 JAX-RS 应用组件(root 资源 和 提供者 类) .本例使用 &lt;code&gt;ResourceConfig&lt;/code&gt;, 是 Jersey 自己实现的 &lt;code&gt;Application&lt;/code&gt; 类，提供了简化  JAX-RS 组件的能力。详见&lt;a href=&quot;https://github.com/waylau/Jersey-2.x-User-Guide/blob/master/Chapter%204.%20Application%20Deployment%20and%20Runtime%20Environments%20%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/4.2.%20JAX-RS%20Application%20Model%20%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B.md&quot;&gt;JAX-RS 应用模型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;org.codingpedia.demo.rest.RestDemoJaxRsApplication&lt;/code&gt; 是自己实现的 &lt;code&gt;ResourceConfig&lt;/code&gt;类，注册应用的  resources, filters, exception mappers 和 feature :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.codingpedia.demo.rest.service;

//imports omitted for brevity 

/**
 * Registers the components to be used by the JAX-RS application
 * 
 * @author ama
 * 
 */
public class RestDemoJaxRsApplication extends ResourceConfig {

    /**
     * Register JAX-RS application components.
     */
    public RestDemoJaxRsApplication() {
        // register application resources
        register(PodcastResource.class);
        register(PodcastLegacyResource.class);

        // register filters
        register(RequestContextFilter.class);
        register(LoggingResponseFilter.class);
        register(CORSResponseFilter.class);

        // register exception mappers
        register(GenericExceptionMapper.class);
        register(AppExceptionMapper.class);
        register(NotFoundExceptionMapper.class);

        // register features
        register(JacksonFeature.class);
        register(MultiPartFeature.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;org.glassfish.jersey.server.spring.scope.RequestContextFilter&lt;/code&gt; 是 Spring filter 提供了 JAX-RS 和 Spring 请求属性之间的桥梁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.codingpedia.demo.rest.resource.PodcastsResource&lt;/code&gt; 这是“外观”组件，通过注解 暴露了 REST 的API。稍后会描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.glassfish.jersey.jackson.JacksonFeature&lt;/code&gt;,是一个  feature ，用 Jackson JSON 的提供者来解释 JSON。&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;2.1.2. Spring 配置&lt;/h4&gt;

&lt;p&gt;配置文件在 classpath 目录下的 spring/applicationContext.xml:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans    
        http://www.springframework.org/schema/beans/spring-beans.xsd

        http://www.springframework.org/schema/tx 
        http://www.springframework.org/schema/tx/spring-tx.xsd

        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &amp;lt;context:component-scan base-package=&quot;org.codingpedia.demo.rest.*&quot; /&amp;gt;

    &amp;lt;!-- ************ JPA configuration *********** --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&amp;gt;  
    &amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;transactionManagerLegacy&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactoryLegacy&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;    
    &amp;lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;persistenceXmlLocation&quot; value=&quot;classpath:config/persistence-demo.xml&quot; /&amp;gt;
        &amp;lt;property name=&quot;persistenceUnitName&quot; value=&quot;demoRestPersistence&quot; /&amp;gt;        
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;restDemoDS&quot; /&amp;gt;
        &amp;lt;property name=&quot;packagesToScan&quot; value=&quot;org.codingpedia.demo.*&quot; /&amp;gt;
        &amp;lt;property name=&quot;jpaVendorAdapter&quot;&amp;gt;
            &amp;lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&amp;gt;
                &amp;lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&amp;gt;
                &amp;lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;     
    &amp;lt;bean id=&quot;entityManagerFactoryLegacy&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;persistenceXmlLocation&quot; value=&quot;classpath:config/persistence-demo.xml&quot; /&amp;gt;
        &amp;lt;property name=&quot;persistenceUnitName&quot; value=&quot;demoRestPersistenceLegacy&quot; /&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;restDemoLegacyDS&quot; /&amp;gt;
        &amp;lt;property name=&quot;packagesToScan&quot; value=&quot;org.codingpedia.demo.*&quot; /&amp;gt;
        &amp;lt;property name=&quot;jpaVendorAdapter&quot;&amp;gt;
            &amp;lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&amp;gt;
                &amp;lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&amp;gt;
                &amp;lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;        

    &amp;lt;bean id=&quot;podcastDao&quot; class=&quot;org.codingpedia.demo.rest.dao.PodcastDaoJPA2Impl&quot;/&amp;gt;    
    &amp;lt;bean id=&quot;podcastService&quot; class=&quot;org.codingpedia.demo.rest.service.PodcastServiceDbAccessImpl&quot; /&amp;gt;    
    &amp;lt;bean id=&quot;podcastsResource&quot; class=&quot;org.codingpedia.demo.rest.resource.PodcastsResource&quot; /&amp;gt;
    &amp;lt;bean id=&quot;podcastLegacyResource&quot; class=&quot;org.codingpedia.demo.rest.resource.PodcastLegacyResource&quot; /&amp;gt;

    &amp;lt;bean id=&quot;restDemoDS&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot; scope=&quot;singleton&quot;&amp;gt;
        &amp;lt;property name=&quot;jndiName&quot; value=&quot;java:comp/env/jdbc/restDemoDB&quot; /&amp;gt;
        &amp;lt;property name=&quot;resourceRef&quot; value=&quot;true&quot; /&amp;gt;        
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;restDemoLegacyDS&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot; scope=&quot;singleton&quot;&amp;gt;
        &amp;lt;property name=&quot;jndiName&quot; value=&quot;java:comp/env/jdbc/restDemoLegacyDB&quot; /&amp;gt;
        &amp;lt;property name=&quot;resourceRef&quot; value=&quot;true&quot; /&amp;gt;        
    &amp;lt;/bean&amp;gt;    
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;podcastsResource&lt;/code&gt;是指向 REST API 实体&lt;/p&gt;

&lt;h2&gt;3. REST API (设计与实现)&lt;/h2&gt;

&lt;h3&gt;3.1. 资源&lt;/h3&gt;

&lt;h4&gt;3.1.1. 设计&lt;/h4&gt;

&lt;p&gt;REST 中的资源主要包括下面两大思想：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个都指向了全球标示符（如，HTTP 中的 &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;有一个或多个表示（我们将在本示例使用 JSON 格式）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;REST 中的资源 一般是名词 (podcasts, customers, user, accounts 等) 而不是名词 (getPodcast, deleteUser 等）&lt;/p&gt;

&lt;p&gt;本教程使用的端点有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/podcasts&lt;/code&gt; – （注意复数）URI标识的资源 podcasts 集合的播客&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/podcasts/{id}&lt;/code&gt; – 通过 podcasts 的ID, URI 标识一个podcasts 资源，&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.1.2. 实现&lt;/h4&gt;

&lt;p&gt;为求精简 ， podcast 只包含下列属性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;id – podcast 的唯一标识&lt;/li&gt;
&lt;li&gt;feed –  podcast 的 feed url&lt;/li&gt;
&lt;li&gt;title – 标题&lt;/li&gt;
&lt;li&gt;linkOnPodcastpedia – 链接&lt;/li&gt;
&lt;li&gt;description – 描述&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我用了两种 Java 类来表示 podcast 代码，是为了避免 类及其属性/方法 被 JPA 和 XML/JAXB/JSON 的注释堆满了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PodcastEntity.java – JPA 注解类用在 DB 和业务层&lt;/li&gt;
&lt;li&gt;Podcast.java – JAXB/JSON 注解类用在外观和业务层&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Podcast.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.codingpedia.demo.rest.resource;

//imports omitted for brevity

/**
 * Podcast resource placeholder for json/xml representation 
 * 
 * @author ama
 *
 */
@SuppressWarnings(&quot;restriction&quot;)
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Podcast implements Serializable {

    private static final long serialVersionUID = -8039686696076337053L;

    /** id of the podcast */
    @XmlElement(name = &quot;id&quot;)    
    private Long id;

    /** title of the podcast */
    @XmlElement(name = &quot;title&quot;)    
    private String title;

    /** link of the podcast on Podcastpedia.org */
    @XmlElement(name = &quot;linkOnPodcastpedia&quot;)    
    private String linkOnPodcastpedia;

    /** url of the feed */
    @XmlElement(name = &quot;feed&quot;)    
    private String feed;

    /** description of the podcast */
    @XmlElement(name = &quot;description&quot;)
    private String description; 

    /** insertion date in the database */
    @XmlElement(name = &quot;insertionDate&quot;)
    @XmlJavaTypeAdapter(DateISO8601Adapter.class)    
    @PodcastDetailedView
    private Date insertionDate;

    public Podcast(PodcastEntity podcastEntity){
        try {
            BeanUtils.copyProperties(this, podcastEntity);
        } catch (IllegalAccessException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public Podcast(String title, String linkOnPodcastpedia, String feed,
            String description) {

        this.title = title;
        this.linkOnPodcastpedia = linkOnPodcastpedia;
        this.feed = feed;
        this.description = description;

    }

    public Podcast(){}

//getters and setters now shown for brevity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转化成 JSON 输出如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;id&quot;:1,
    &quot;title&quot;:&quot;Quarks &amp;amp; Co - zum Mitnehmen-modified&quot;,
    &quot;linkOnPodcastpedia&quot;:&quot;http://www.podcastpedia.org/podcasts/1/Quarks-Co-zum-Mitnehmen&quot;,
    &quot;feed&quot;:&quot;http://podcast.wdr.de/quarks.xml&quot;,
    &quot;description&quot;:&quot;Quarks &amp;amp; Co: Das Wissenschaftsmagazin&quot;,
    &quot;insertionDate&quot;:&quot;2014-05-30T10:26:12.00+0200&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.2. 方法&lt;/h3&gt;

&lt;p&gt;简单的说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建 = POST&lt;/li&gt;
&lt;li&gt;读 = GET&lt;/li&gt;
&lt;li&gt;更新 = PUT&lt;/li&gt;
&lt;li&gt;删除 = DELETE&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;但不是一一映射，因为 PUT 也可以创建， POST也可以用在更新。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：读取和删除它是很清楚的，他们确实是和 GET 、DELETE一对一的映射。无论如何，REST 是一种架构风格，不是一个规范，你应该适应你的架构需要，但如果你想让你的 API 让更多的公众愿意使用它，你应该遵循一定的“最佳实践”。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PodcastRestResource&lt;/code&gt; 类 是处理所有的请求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.codingpedia.demo.rest.resource;
//imports
......................
@Component
@Path(&quot;/podcasts&quot;)
public class PodcastResource {
    @Autowired
    private PodcastService podcastService;
    .....................
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 类定义前面的 &lt;code&gt;@Path(&quot;/podcasts&quot;)&lt;/code&gt;，所有与 podcast 关联的资源都会出现在 这个路径下。 @Path 注解值是关联 URI 的路径。&lt;/p&gt;

&lt;p&gt;在上面的例子中，该 Java 类将托管在&lt;code&gt;/podcasts&lt;/code&gt; URI 路径。&lt;code&gt;PodcastService&lt;/code&gt; 接口公开的业务逻辑 到 REST 外观层。&lt;/p&gt;

&lt;h4&gt;3.2.1. 创建 podcast&lt;/h4&gt;

&lt;h4&gt;3.2.1.1. 设计&lt;/h4&gt;

&lt;p&gt;常见的的方式利用 POST 创建资源，如前所述，创建一个新的资源，可以用 POST 和 PUT 的方法，我是这样做的：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;tbody&gt;
&lt;tr valign=&quot;TOP&quot;&gt;
&lt;td bgcolor=&quot;#808080&quot; width=&quot;25%&quot;&gt;&lt;b&gt;&amp;nbsp; Description&lt;/b&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#808080&quot; width=&quot;25%&quot;&gt;&lt;b&gt;&amp;nbsp; URI&lt;/b&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#808080&quot; width=&quot;25%&quot;&gt;&lt;b&gt;&amp;nbsp; HTTP method&lt;br&gt;
&lt;/b&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#808080&quot; width=&quot;25%&quot;&gt;&lt;b&gt;&amp;nbsp; HTTP Status response&lt;/b&gt;&lt;/td&gt;
&lt;iframe id=&quot;tmp_downloadhelper_iframe&quot; style=&quot;display: none;&quot;&gt;&lt;/iframe&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;25%&quot; height=&quot;19&quot;&gt;&amp;nbsp;增加新的 podcast&lt;/td&gt;
&lt;td width=&quot;25%&quot;&gt;&amp;nbsp;/podcasts/&lt;/td&gt;
&lt;td width=&quot;25%&quot;&gt;
&lt;p align=&quot;CENTER&quot;&gt;POST&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;25%&quot;&gt;
&lt;p align=&quot;CENTER&quot;&gt;201 Created&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;25%&quot; height=&quot;19&quot;&gt;&amp;nbsp;增加新的 podcast (必须传所有的值)&lt;/td&gt;
&lt;td width=&quot;25%&quot;&gt;&amp;nbsp;/podcasts/{id}&lt;/td&gt;
&lt;td width=&quot;25%&quot;&gt;
&lt;p align=&quot;CENTER&quot;&gt;PUT&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;25%&quot;&gt;
&lt;p align=&quot;CENTER&quot;&gt;201 Created&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;PUT  POST 最大的区别是 ，PUT 就是把你应该事先知道资源将被创建的位置和发送所有可能值的实体。&lt;/p&gt;

&lt;h5&gt;3.2.1.2. 实现&lt;/h5&gt;

&lt;h6&gt;3.2.1.2.1. POST 创建一个单资源&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Adds a new resource (podcast) from the given json format (at least title
 * and feed elements are required at the DB level)
 * 
 * @param podcast
 * @return
 * @throws AppException
 */
@POST
@Consumes({ MediaType.APPLICATION_JSON })
@Produces({ MediaType.TEXT_HTML })
public Response createPodcast(Podcast podcast) throws AppException {
    Long createPodcastId = podcastService.createPodcast(podcast);
    return Response.status(Response.Status.CREATED)// 201
            .entity(&quot;A new podcast has been created&quot;)
            .header(&quot;Location&quot;,
                    &quot;http://localhost:8888/demo-rest-jersey-spring/podcasts/&quot;
                            + String.valueOf(createPodcastId)).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@POST – 指示方法响应到 HTTP POST 请求&lt;/li&gt;
&lt;li&gt;@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为&quot;application/json&quot;&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.TEXT_HTML}) – 定义方法产生的媒体类型本例为 &quot;text/html&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 201 的 text/html 文件和头的位置指定的资源已被创建&lt;/li&gt;
&lt;li&gt;错误:

&lt;ul&gt;
&lt;li&gt;400：没有足够的数据提供&lt;/li&gt;
&lt;li&gt;409：冲突了。如果在服务器端被确定 具有相同的 podcast 的存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h6&gt;3.2.1.2.2. 通过 PUT 创建单资源 (“podcast”)&lt;/h6&gt;

&lt;p&gt;这将执行 更新 Podcast 处理。&lt;/p&gt;

&lt;h6&gt;3.2.1.2.3. 附加 – 通过表单创建 (“podcast”)资源&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Adds a new podcast (resource) from &quot;form&quot; (at least title and feed
 * elements are required at the DB level)
 * 
 * @param title
 * @param linkOnPodcastpedia
 * @param feed
 * @param description
 * @return
 * @throws AppException
 */
@POST
@Consumes({ MediaType.APPLICATION_FORM_URLENCODED })
@Produces({ MediaType.TEXT_HTML })
@Transactional
public Response createPodcastFromApplicationFormURLencoded(
        @FormParam(&quot;title&quot;) String title,
        @FormParam(&quot;linkOnPodcastpedia&quot;) String linkOnPodcastpedia,
        @FormParam(&quot;feed&quot;) String feed,
        @FormParam(&quot;description&quot;) String description) throws AppException {

    Podcast podcast = new Podcast(title, linkOnPodcastpedia, feed,
            description);
    Long createPodcastid = podcastService.createPodcast(podcast);

    return Response
            .status(Response.Status.CREATED)// 201
            .entity(&quot;A new podcast/resource has been created at /demo-rest-jersey-spring/podcasts/&quot;
                    + createPodcastid)
            .header(&quot;Location&quot;,
                    &quot;http://localhost:8888/demo-rest-jersey-spring/podcasts/&quot;
                            + String.valueOf(createPodcastid)).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@POST – 指示方法响应到 HTTP POST 请求&lt;/li&gt;
&lt;li&gt;@Consumes({MediaType.APPLICATION_FORM_URLENCODED}) – 定义方法可以接受的媒体类型，本例为&quot;application/x-www-form-urlencoded&quot;&lt;/li&gt;
&lt;li&gt;@FormParam – 这个注解绑定的表单参数值包含了请求对应资源方法参数的实体。值是 URL  的解码，除非 禁用 解码的注解。&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.TEXT_HTML}) – 定义方法产生的媒体类型本例为 &quot;text/html&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 201 的 text/html 文件和头的位置指定的资源已被创建&lt;/li&gt;
&lt;li&gt;错误:

&lt;ul&gt;
&lt;li&gt;400：没有足够的数据提供&lt;/li&gt;
&lt;li&gt;409：冲突了。如果在服务器端被确定 具有相同的 podcast 的存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.2.2. 读 podcast&lt;/h4&gt;

&lt;h5&gt;3.2.2.1. 设计&lt;/h5&gt;

&lt;p&gt;API 支持两种操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;返回 podcast 的集合&lt;/li&gt;
&lt;li&gt;根据 id 返回  podcast&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;tbody align=&quot;center&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;&amp;nbsp;Description&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;&amp;nbsp;URI&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;&amp;nbsp;HTTP method&lt;br&gt; &lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;&amp;nbsp;HTTP Status response&lt;/b&gt;&lt;/td&gt;&lt;iframe id=&quot;tmp_downloadhelper_iframe&quot; style=&quot;display: none;&quot;&gt;&lt;/iframe&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;返回所有 podcast &lt;/td&gt;&lt;td&gt;&amp;nbsp;/podcasts/?orderByInsertionDate={ASC|DESC}&amp;amp;numberDaysToLookBack={val}&lt;/td&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;200&amp;nbsp;OK&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;添加新的 podcast (所有值都要传递)&lt;/td&gt;&lt;td&gt;&amp;nbsp;/podcasts/{id}&lt;/td&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;200&amp;nbsp;OK&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/p&gt;

&lt;p&gt;注意到集合资源的参数–rderByInsertionDate 和 numberDaysToLookBack。在URI查询参数添加过滤器而不是路径的一部分这个是很有道理的。&lt;/p&gt;

&lt;h5&gt;3.2.2.2. 实现&lt;/h5&gt;

&lt;h6&gt;3.2.2.2.1. 获取所有 podcasts (“/”)&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Returns all resources (podcasts) from the database
 * 
 * @return
 * @throws IOException
 * @throws JsonMappingException
 * @throws JsonGenerationException
 * @throws AppException
 */
@GET
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public List&amp;lt;Podcast&amp;gt; getPodcasts(
        @QueryParam(&quot;orderByInsertionDate&quot;) String orderByInsertionDate,
        @QueryParam(&quot;numberDaysToLookBack&quot;) Integer numberDaysToLookBack)
        throws JsonGenerationException, JsonMappingException, IOException,
        AppException {
    List&amp;lt;Podcast&amp;gt; podcasts = podcastService.getPodcasts(
            orderByInsertionDate, numberDaysToLookBack);
    return podcasts;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@GET – 指示方法响应到 HTTP GET 请求&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) – 定义方法可以接受的媒体类型，本例为&quot;application/json&quot; 或者 &quot;application/xml&quot;（在 Podcast 类前 添加  @XmlRootElement ），将返回  JSON 或者 XML 格式的 podcast 集合&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 200 的 podcast 数据集合&lt;/li&gt;
&lt;/ul&gt;


&lt;h6&gt;3.2.2.2.1. 读一个 podcast&lt;/h6&gt;

&lt;p&gt;根据 id  获取一个 podcast&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@GET
@Path(&quot;{id}&quot;)
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public Response getPodcastById(@PathParam(&quot;id&quot;) Long id)
        throws JsonGenerationException, JsonMappingException, IOException,
        AppException {
    Podcast podcastById = podcastService.getPodcastById(id);
    return Response.status(200).entity(podcastById)
            .header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-extra-header&quot;)
            .allow(&quot;OPTIONS&quot;).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@GET – 指示方法响应到 HTTP GET 请求&lt;/li&gt;
&lt;li&gt;@PathParam(&quot;id&quot;)- 绑定传递的参数值&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) – 定义方法可以接受的媒体类型，本例为&quot;application/json&quot; 或者 &quot;application/xml&quot;（在 Podcast 类前 添加  @XmlRootElement ），将返回  JSON 或者 XML 格式的 podcast 集合&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 200 的 podcast&lt;/li&gt;
&lt;li&gt;错误： 404 Not found。如果没有在数据库中找到&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.2.3. 更新 podcast&lt;/h4&gt;

&lt;h5&gt;3.2.3.1. 设计&lt;/h5&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;5&quot; border=&quot;1&quot; align=&quot;center&quot; style=&quot;width:600px&quot;&gt;&lt;tbody align=&quot;center&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Description&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;URI&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;HTTP method&lt;br&gt; &lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;HTTP Status response&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;更新 podcast (&lt;strong&gt;完全&lt;/strong&gt;)&lt;/td&gt;&lt;td&gt;&amp;nbsp;/podcasts/{id}&lt;/td&gt;&lt;td&gt;PUT&lt;/td&gt;&lt;td&gt;200&amp;nbsp;OK&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;更新 podcast (&lt;strong&gt;部分&lt;/strong&gt;)&lt;/td&gt;&lt;td&gt;&amp;nbsp;/podcasts/{id}&lt;/td&gt;&lt;td&gt;POST&lt;/td&gt;&lt;td&gt;200&amp;nbsp;OK&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;1.完全更新  – 提供所有的值
2.部分更新  – 传递部分属性值即可&lt;/p&gt;

&lt;h5&gt;3.2.3.1. 实现&lt;/h5&gt;

&lt;h6&gt;3.2.3.1.1. 完全更新&lt;/h6&gt;

&lt;p&gt;创建或者完全更新资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@PUT
@Path(&quot;{id}&quot;)
@Consumes({ MediaType.APPLICATION_JSON })
@Produces({ MediaType.TEXT_HTML })
public Response putPodcastById(@PathParam(&quot;id&quot;) Long id, Podcast podcast)
        throws AppException {

    Podcast podcastById = podcastService.verifyPodcastExistenceById(id);

    if (podcastById == null) {
        // resource not existent yet, and should be created under the
        // specified URI
        Long createPodcastId = podcastService.createPodcast(podcast);
        return Response
                .status(Response.Status.CREATED)
                // 201
                .entity(&quot;A new podcast has been created AT THE LOCATION you specified&quot;)
                .header(&quot;Location&quot;,
                        &quot;http://localhost:8888/demo-rest-jersey-spring/podcasts/&quot;
                                + String.valueOf(createPodcastId)).build();
    } else {
        // resource is existent and a full update should occur
        podcastService.updateFullyPodcast(podcast);
        return Response
                .status(Response.Status.OK)
                // 200
                .entity(&quot;The podcast you specified has been fully updated created AT THE LOCATION you specified&quot;)
                .header(&quot;Location&quot;,
                        &quot;http://localhost:8888/demo-rest-jersey-spring/podcasts/&quot;
                                + String.valueOf(id)).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@PUT – 指示方法响应到 HTTP PUT  请求&lt;/li&gt;
&lt;li&gt;@PathParam(&quot;id&quot;)- 绑定传递的参数值&lt;/li&gt;
&lt;li&gt;@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为&quot;application/json&quot;&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为t&quot;ext/html&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 201 Created&lt;/li&gt;
&lt;li&gt;错误： 400 Bad Request。如果需要的属性值没有提供&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完全更新：

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 200&lt;/li&gt;
&lt;li&gt;错误： 400 Bad Request。如果不是所有的属性都提供&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h6&gt;3.2.3.1.2. 部分更新&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;//PARTIAL update
@POST
@Path(&quot;{id}&quot;)   
@Consumes({ MediaType.APPLICATION_JSON })
@Produces({ MediaType.TEXT_HTML })
public Response partialUpdatePodcast(@PathParam(&quot;id&quot;) Long id, Podcast podcast) throws AppException {
    podcast.setId(id);
    podcastService.updatePartiallyPodcast(podcast);
    return Response.status(Response.Status.OK)// 200
            .entity(&quot;The podcast you specified has been successfully updated&quot;)
            .build();   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@POST – 指示方法响应到 HTTP POST 请求&lt;/li&gt;
&lt;li&gt;@PathParam(&quot;id&quot;)- 绑定传递的参数值&lt;/li&gt;
&lt;li&gt;@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为&quot;application/json&quot;&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为t&quot;ext/html&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 200 OK&lt;/li&gt;
&lt;li&gt;错误： 404 Not Found。如果资源不存在&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.2.4. 删除 podcast&lt;/h4&gt;

&lt;h5&gt;3.2.4.1. 设计&lt;/h5&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;5&quot; border=&quot;1&quot; align=&quot;center&quot; style=&quot;width:700px&quot;&gt;&lt;tbody align=&quot;center&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Description&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;URI&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;HTTP method&lt;br&gt; &lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;HTTP Status response&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;移除所有 podcasts&lt;/td&gt;&lt;td&gt;&amp;nbsp;/podcasts/&lt;/td&gt;&lt;td&gt;DELETE&lt;/td&gt;&lt;td&gt;204 No content&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;移除特定位置的 podcast&lt;/td&gt;&lt;td&gt;&amp;nbsp;/podcasts/{id}&lt;/td&gt;&lt;td&gt;DELETE&lt;/td&gt;&lt;td&gt;204 No content&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h5&gt;3.2.4.2. 实现&lt;/h5&gt;

&lt;h6&gt;3.2.4.2.1. 删除所有资源&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;@DELETE
@Produces({ MediaType.TEXT_HTML })
public Response deletePodcasts() {
    podcastService.deletePodcasts();
    return Response.status(Response.Status.NO_CONTENT)// 204
            .entity(&quot;All podcasts have been successfully removed&quot;).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@DELETE – 指示方法响应到 HTTP DELETE  请求&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为&quot;text/html&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;返回 html  文档&lt;/li&gt;
&lt;/ul&gt;


&lt;h6&gt;3.2.4.2.2. 删除一个资源&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;@DELETE
@Path(&quot;{id}&quot;)
@Produces({ MediaType.TEXT_HTML })
public Response deletePodcastById(@PathParam(&quot;id&quot;) Long id) {
    podcastService.deletePodcastById(id);
    return Response.status(Response.Status.NO_CONTENT)// 204
            .entity(&quot;Podcast successfully removed from database&quot;).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@DELETE – 指示方法响应到 HTTP DELETE 请求&lt;/li&gt;
&lt;li&gt;@PathParam(&quot;id&quot;)- 绑定传递的参数值&lt;/li&gt;
&lt;li&gt;@Consumes({MediaType.APPLICATION_JSON}) – 定义方法可以接受的媒体类型，本例为&quot;application/json&quot;&lt;/li&gt;
&lt;li&gt;@Produces({MediaType.TEXT_HTML}) – 定义方法可以产生的媒体类型，本例为&quot;text/html&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;响应&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;成功: HTTP 状态 为 204 No Content&lt;/li&gt;
&lt;li&gt;错误： 404 Not Found。如果资源不存在&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;4. 日志&lt;/h2&gt;

&lt;p&gt;详见 &lt;a href=&quot;http://www.codingpedia.org/ama/how-to-log-in-spring-with-slf4j-and-logback/&quot;&gt;http://www.codingpedia.org/ama/how-to-log-in-spring-with-slf4j-and-logback/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;5. 异常处理&lt;/h2&gt;

&lt;p&gt;错误处理要有统一的格式，就像下面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
   &quot;status&quot;: 400,
   &quot;code&quot;: 400,
   &quot;message&quot;: &quot;Provided data not sufficient for insertion&quot;,
   &quot;link&quot;: &quot;http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-with-jersey-and-spring&quot;,
   &quot;developerMessage&quot;: &quot;Please verify that the feed is properly generated/set&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;6. 服务端添加 CORS 支持&lt;/h2&gt;

&lt;h2&gt;7. 测试&lt;/h2&gt;

&lt;h3&gt;7.1. 在Java集成测试&lt;/h3&gt;

&lt;h3&gt;7.1.1. 配置&lt;/h3&gt;

&lt;h5&gt;7.1.1.1 Jersey 客户端依赖&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.glassfish.jersey.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jersey-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${jersey.version}&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;7.1.1.2. Failsafe 插件&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugins&amp;gt;
    [...]
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-failsafe-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.16&amp;lt;/version&amp;gt;
        &amp;lt;executions&amp;gt;
            &amp;lt;execution&amp;gt;
                &amp;lt;id&amp;gt;integration-test&amp;lt;/id&amp;gt;
                &amp;lt;goals&amp;gt;
                    &amp;lt;goal&amp;gt;integration-test&amp;lt;/goal&amp;gt;
                &amp;lt;/goals&amp;gt;
            &amp;lt;/execution&amp;gt;
            &amp;lt;execution&amp;gt;
                &amp;lt;id&amp;gt;verify&amp;lt;/id&amp;gt;
                &amp;lt;goals&amp;gt;
                    &amp;lt;goal&amp;gt;verify&amp;lt;/goal&amp;gt;
                &amp;lt;/goals&amp;gt;
            &amp;lt;/execution&amp;gt;
        &amp;lt;/executions&amp;gt;
    &amp;lt;/plugin&amp;gt;
    [...]
&amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;7.1.1.2. Jetty Maven 插件&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugins&amp;gt;
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.eclipse.jetty&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jetty-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${jetty.version}&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;jettyConfig&amp;gt;${project.basedir}/src/main/resources/config/jetty9.xml&amp;lt;/jettyConfig&amp;gt;
            &amp;lt;stopKey&amp;gt;STOP&amp;lt;/stopKey&amp;gt;
            &amp;lt;stopPort&amp;gt;9999&amp;lt;/stopPort&amp;gt;
            &amp;lt;stopWait&amp;gt;5&amp;lt;/stopWait&amp;gt;
            &amp;lt;scanIntervalSeconds&amp;gt;5&amp;lt;/scanIntervalSeconds&amp;gt;
        [...]
        &amp;lt;/configuration&amp;gt;
        &amp;lt;executions&amp;gt;
            &amp;lt;execution&amp;gt;
                &amp;lt;id&amp;gt;start-jetty&amp;lt;/id&amp;gt;
                &amp;lt;phase&amp;gt;pre-integration-test&amp;lt;/phase&amp;gt;
                &amp;lt;goals&amp;gt;
                    &amp;lt;!-- stop any previous instance to free up the port --&amp;gt;
                    &amp;lt;goal&amp;gt;stop&amp;lt;/goal&amp;gt;               
                    &amp;lt;goal&amp;gt;run-exploded&amp;lt;/goal&amp;gt;
                &amp;lt;/goals&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;scanIntervalSeconds&amp;gt;0&amp;lt;/scanIntervalSeconds&amp;gt;
                    &amp;lt;daemon&amp;gt;true&amp;lt;/daemon&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/execution&amp;gt;
            &amp;lt;execution&amp;gt;
                &amp;lt;id&amp;gt;stop-jetty&amp;lt;/id&amp;gt;
                &amp;lt;phase&amp;gt;post-integration-test&amp;lt;/phase&amp;gt;
                &amp;lt;goals&amp;gt;
                    &amp;lt;goal&amp;gt;stop&amp;lt;/goal&amp;gt;
                &amp;lt;/goals&amp;gt;
            &amp;lt;/execution&amp;gt;
        &amp;lt;/executions&amp;gt;
    &amp;lt;/plugin&amp;gt;
    [...]
&amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细配置见源码中的 pom.xml&lt;/p&gt;

&lt;h4&gt;7.1.2. 编译集成测试&lt;/h4&gt;

&lt;p&gt;使用 JUnit  作为测试框架。默认的 Failsafe 插件 自动包含所有测试类&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&quot;&lt;em&gt;*/IT&lt;/em&gt;.java&quot; – “IT”开头的文件.&lt;/li&gt;
&lt;li&gt;&quot;&lt;em&gt;*/&lt;/em&gt;IT.java&quot; – “IT”结尾的文件.&lt;/li&gt;
&lt;li&gt;&quot;&lt;em&gt;*/&lt;/em&gt;ITCase.java&quot; – “ITCase”结尾的文件.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;创建了测试类 RestDemoServiceIT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class RestDemoServiceIT {

    [....]
    @Test
    public void testGetPodcast() throws JsonGenerationException,
            JsonMappingException, IOException {

        ClientConfig clientConfig = new ClientConfig();
        clientConfig.register(JacksonFeature.class);

        Client client = ClientBuilder.newClient(clientConfig);

        WebTarget webTarget = client
                .target(&quot;http://localhost:8888/demo-rest-jersey-spring/podcasts/2&quot;);

        Builder request = webTarget.request(MediaType.APPLICATION_JSON);

        Response response = request.get();
        Assert.assertTrue(response.getStatus() == 200);

        Podcast podcast = response.readEntity(Podcast.class);

        ObjectMapper mapper = new ObjectMapper();
        System.out
                .print(&quot;Received podcast from database *************************** &quot;
                        + mapper.writerWithDefaultPrettyPrinter()
                                .writeValueAsString(podcast));

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在客户也要注册 JacksonFeature ，这样才能解析 JSON格式&lt;/li&gt;
&lt;li&gt;用 jetty 测试，端口 8888&lt;/li&gt;
&lt;li&gt;期望 返回 200 状态 给我们的请求&lt;/li&gt;
&lt;li&gt;org.codehaus.jackson.map.ObjectMapper 帮助返回格式化的 JSON&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;7.1.3. 运行集成测试&lt;/h4&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn verify
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置  &lt;code&gt;jetty.port&lt;/code&gt; 属性到 8888,Eclipse  配置如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/run-integration-tests-eclipse.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;7.2. 用 SoapUI 集成测试&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=XV7WW0bDy9c&quot;&gt;youtube视频教程&lt;/a&gt;（需翻墙）&lt;/p&gt;

&lt;h2&gt;8. 版本管理&lt;/h2&gt;

&lt;p&gt;几个要点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;URL:  “/v1/podcasts/{id}”&lt;/li&gt;
&lt;li&gt;Accept/Content-type header: application/json; version=1&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在 路径中 加入 版本信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
@Path(&quot;/v1/podcasts&quot;)
public class PodcastResource {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jersey.java.net/&quot;&gt;https://jersey.java.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/waylau/Jersey-2.x-User-Guide&quot;&gt;https://github.com/waylau/Jersey-2.x-User-Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-in-java-with-jersey-and-spring/&quot;&gt;http://www.codingpedia.org/ama/tutorial-rest-api-design-and-implementation-in-java-with-jersey-and-spring/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 22 Nov 2014 02:41:00 +0800</pubDate>
        <link>http://www.waylau.com/jersey-2-spring-4-rest/</link>
        <guid isPermaLink="true">http://www.waylau.com/jersey-2-spring-4-rest/</guid>
        
        <category>jersey</category>
        
      </item>
    
      <item>
        <title>设置 VPN,通过 VPN 翻墙科学上网</title>
        <description>&lt;p&gt;之前介绍了《&lt;a href=&quot;http://www.waylau.com/about-vpngate/&quot;&gt;用 VPN Gate 翻墙科学上网&lt;/a&gt;》,通过安装客户端，方便实现 VPN 的连接。如果 你爱折腾，也可以手动设置 VPN 。这样的连接 更加稳定。&lt;/p&gt;

&lt;h2&gt;什么是VPN&lt;/h2&gt;

&lt;p&gt;虚拟专用网(VPN)被定义为通过一个公用网络(通常是因特网)建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。虚拟专用网是对企业内部网的扩展。&lt;/p&gt;

&lt;h2&gt;VPN 能做啥&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;连接公共 VPN 服务器获得自由访问互联网（翻墙）。&lt;/li&gt;
&lt;li&gt;绕过您的本地故障防火墙的数据包拦截，并安全地隐藏你的 IP 地址。&lt;/li&gt;
&lt;li&gt;安全加密网络信号。当你通过互联网发送信息时，保护您的隐私。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;在 windows 上设置 VPN&lt;/h2&gt;

&lt;p&gt;1.打开网络共享中心&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn001_zps9fa844e1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.设置新连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn002_zps7054fdfe.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3.选择 VPN连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn003_zps0af36d2d.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.建一个新的连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn004_zps368e912d.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5.选择使用 VPN&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn005_zps0631dea5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6.输入 VPN 的 IP&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn006_zpsc9e05e36.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;7.输入 VPN  的账号、密码，最好就记住&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn007_zpsf1c75c9a.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8.此时连接可以用了。可以马上连，也可以稍后连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn008_zpsb0c0b05e.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9.VPN 连接已经创建，右键可以执行“连接”“断开”等操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/vpn/vpn009_zps8af40472.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;在 Android 上设置 VPN&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;初始配置 (只需在第一次时安装一次)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;从安卓启动 &quot;Settings&quot; 应用程序。
在 &quot;Wireless &amp;amp; Networks&quot; 类别中，打开 &quot;More...&quot; 并点击 &quot;VPN&quot;。
点击 &quot;Add VPN profile&quot; 按钮来创建一个新的 VPN 连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/001%2812%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个新的 VPN 连接设置编辑屏幕将出现。在 &quot;Name&quot; 字段输入一些字符串 (如 &quot;vpn&quot; ) ，并在 &quot;Type&quot; 字段选择类型，如 &quot;L2TP/IPSec PSK&quot; 。
在此屏幕上，你必须指定 VPN 主机名或 IP 地址。
复制 DDNS 主机名称 (以 &quot;.opengw.net&quot; 标识符结尾) 或 IP 地址 (位数如:xxx.xxx.xxx.xxx) 并粘贴它到配置屏幕的 &quot;Server address&quot; 字段。&lt;/p&gt;

&lt;p&gt;一般情况下，建议指定 DDNS 主机名称 (以 &quot;.opengw.net&quot; 标识符结尾)。DDNS 主机名称可以继续使用，即使 DDNS 主机名对应的 IP 地址将来被改变。然而，在某些国家或地区，您可能无法使用 DDNS 主机名称。如果你不能指定 DDNS 主机名称，尝试使用 IP 地址 (位数如 xxx.xxx.xxx.xxx) 规格来代替。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/002l.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;向下滚动配置屏幕，并点击 &quot;Show advanced options&quot; 复选框，如果合适的话。
在 &quot;IPSec pre-shared key&quot; 字段输入 vpn  的密码，
在 &quot;Forwarding routes&quot; 字段输入 &quot;0.0.0.0/0&quot; (9 个字母)。请确定你在 &quot;Forwarding routes&quot; 字段输入正确。如果不对，你不能通过 VPN 通信。
所有输完后，点击 &quot;Save&quot; 按钮并保存 VPN 连接设置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/002l.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接 VPN&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在任何时候通过使用已创建的 VPN 连接设置，您可以开始一个 VPN 连接。打开 VPN 连接设置列表并点击设置，你将看到以下屏幕。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/004%284%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在第一次使用时，你必须输入&quot;Username&quot; 和 &quot;Password&quot; 字段。
然后选择 &quot;Save account information&quot;。
点击 &quot;Connect&quot; 开始 VPN 连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/005%283%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VPN 连接建立后，指示字符串 &quot;Connected&quot; 将显示在 VPN 连接设置旁，安卓的状态指示区将显示 &quot;VPN activated&quot; 消息。您可以点击消息看当前 VPN 连接状态。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过 VPN 中继享受互联网&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;当 VPN 建立时，所有到互联网的通讯将通过 VPN 服务器转发。
如果你连接到一个位于海外国家的 VPN 服务器，当你的 VPN 连接建立时，享受 YouTube、Facebook 或 Twitter 吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://99btgc01.info/uploads/2014/11/006%283%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;使用免费的 VPN&lt;/h2&gt;

&lt;p&gt;这里提供可使用的免费的 VPN，&lt;a href=&quot;https://github.com/waylau/free-vpn&quot;&gt;https://github.com/waylau/free-vpn&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Nov 2014 02:41:00 +0800</pubDate>
        <link>http://www.waylau.com/vpn-setting/</link>
        <guid isPermaLink="true">http://www.waylau.com/vpn-setting/</guid>
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>壮哉我军大字标语，亮瞎美帝的狗眼！</title>
        <description>&lt;p&gt;茫茫大戈壁，随处可见的大字标语彰显我军的战斗精神！用美帝的谷歌卫星地图，清晰看到这一道道独特的风景。&lt;/p&gt;

&lt;p&gt;用&lt;a href=&quot;http://ditu.google.cn/maps?output=classic&amp;amp;dg=ctry&quot;&gt;谷歌地图&lt;/a&gt;输入坐标即可&lt;/p&gt;

&lt;p&gt;苦练精兵： 43°43 45.72 N, 87°40 12.59 E&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/82E67EC37CBE5175_zps9ae0a661.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;卫国戍边以卡为家： 45°22 3.47 N, 90°34 23.67 E&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/536B56FD_zpsa2da0d8b.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;严格要求严格训练： 45° 6 56.73 N, 82°31 32.44 E&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/4E25683C89816C42_zpsb27a5566.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;只争朝夕: 42 39 33.30 n,94 16 00.56 e&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/53EA4E89671D5915_zpsba4a4f63.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为人民服务: 42 32 33.95 n,94 19 36.80 e&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/4E3A4EBA6C11_zpsd5944b53.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;毛主席万岁: 42 39 18.85 n,94 10 00.80 e&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/6BDB_zps9ac9f968.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;时刻准备打仗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/65F6523B80FD6253_zps63eb9a60.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其他&lt;/p&gt;

&lt;p&gt;壮我大中华39 41 43.75,73 55 37.39&lt;/p&gt;

&lt;p&gt;排除万难去争取胜利 42 27 12.08 n,94 08 49.36 e&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Nov 2014 01:41:00 +0800</pubDate>
        <link>http://www.waylau.com/pla-big-slogan/</link>
        <guid isPermaLink="true">http://www.waylau.com/pla-big-slogan/</guid>
        
        <category>outdoor</category>
        
      </item>
    
      <item>
        <title>用 VPN Gate 翻墙科学上网</title>
        <description>&lt;h2&gt;VPN Gate 综述&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/vpn-top_zps08e8f3c2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.vpngate.net/&quot;&gt;VPN Gate&lt;/a&gt; 学术实验项目是一个在线服务，由日本国立筑波大学研究生院为学术研究目的运营。本研究的目的是推广 &quot;全球分布式公共 VPN 中继服务器&quot; 的知识。&lt;/p&gt;

&lt;h2&gt;VPN Gate 公共 VPN 中继服务器&lt;/h2&gt;

&lt;p&gt;在 VPN Gate 学术项目网站上有一个公共 VPN 中继服务器列表。互联网上的任何人都可以建立 VPN 连接至任一列表上的 VPN 服务器。无需用户注册。&lt;/p&gt;

&lt;h2&gt;VPN Gate 公共 VPN 中继服务器的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;VPN Gate 包括许多由世界各地的志愿者所提供的 VPN 服务器。
您可以提供自己的电脑作为一个 VPN 服务器加入到这个实验中。&lt;/li&gt;
&lt;li&gt;Windows, Mac, iPhone, iPad 和安卓都可以连接到 VPN Gate 服务器。&lt;/li&gt;
&lt;li&gt;支持 SSL-VPN (SoftEther VPN) 协议， L2TP/IPsec 协议， OpenVPN 协议和 Microsoft SSTP 协议。&lt;/li&gt;
&lt;li&gt;接受匿名连接。无需用户注册。&lt;/li&gt;
&lt;li&gt;每个 VPN 服务器的 IP 地址是不固定的。 IP 地址可能会不定期改变。&lt;/li&gt;
&lt;li&gt;每天 VPN 服务器会有增加和减少。因此，所有 VPN 服务器不处于特定 IP 地址范围。&lt;/li&gt;
&lt;li&gt;当一个 VPN 客户端连接到 VPN 服务器时， VPN 客户端可以通过那台 VPN 服务器访问互联网。您可以隐藏你的客户端的 IP 地址。&lt;/li&gt;
&lt;li&gt;当您使用一个在物理上位于海外国家的 VPN 服务器，您的任何通信都被认为，好像是从该国发起的。然后你就可以通过使用 VPN Gate 访问网站了，这通常是无法从您所在的国家访问的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;想要解决的问题&lt;/h2&gt;

&lt;h3&gt;存在的问题 1: 政府的防火墙有时未通过，一些海外网站变得遥不可及。&lt;/h3&gt;

&lt;p&gt;某些国家的防火墙由于 &quot;未知故障&quot; 导致通信失败。例如，你在某一国家旅行，并尝试访问 YouTube， Twitter， Facebook 等网站，但却失败了。然而，你却可以访问到其他的海外网站，如雅虎等。&lt;/p&gt;

&lt;h3&gt;存在的问题 2: 通过跟踪一个服务器访问日志的 IP 地址，可以确定一个人的隐私信息。&lt;/h3&gt;

&lt;p&gt;如果您访问网站或发送电子邮件，你的源 IP 地址将被记录在目标 Web 服务器上，或在包含有电子邮件内容的包头里。&lt;/p&gt;

&lt;p&gt;一个 IP 地址不仅仅是个人信息。然而， IP 地址可以被用来跟踪在各个网站产生活动的个人。这种跟踪技术常被用于垃圾邮件或强制广告中。&lt;/p&gt;

&lt;p&gt;此外，通过法律的强制执行程序，一个 IP 地址可以被用来确定谁是发起相关通信的人。警察、检察官或律师可以使用其特权要求互联网服务供应商主持的 IP 地址分配的日志文件。在平常的时候，这样的 IP 地址分配日志通常由互联网服务供应商附上。然而，一旦有人获得日志，他可以调查谁发送了电子邮件、或谁发布到网站上一条消息。&lt;/p&gt;

&lt;p&gt;此外，在互联网上，一个人在特定时间被分配了一个特定 IP 地址的人将被视为与在同一时间从此 IP 地址发起的任何非法通信有责任。最近在日本，执法者的可耻事件做为严重的问题被批评，执法人员错误地逮捕了从来没有在他的电脑上进行非法事情的无辜互联网用户，而是电脑感染了木马，被真正的犯人远程控制。真正的犯人让无辜的互联网用户的计算机发送敲诈邮件给一些公司，无辜的人被执法人员不公正地逮捕。无辜的人最终被释放，但这是在日本近代历史上最糟糕的诬告事件之一。&lt;/p&gt;

&lt;p&gt;因此，当你访问互联网时，最好有一个方法来暂时隐藏你的真实 IP 地址。如果你的真实 IP 地址被隐藏，没有广告目的的 IP 地址的追踪将是不成功的。IP 地址可追溯性的风险将会降低。如果隐藏你的真实 IP 地址连接到互联网时，即使你的电脑感染了木马或恶意软件，错误逮捕的风险将永远不会给你。&lt;/p&gt;

&lt;h3&gt;存在的问题 3: 公共 Wi-Fi 存在数据包被窃听的风险&lt;/h3&gt;

&lt;p&gt;大多数公共 Wi-Fi 可以被人窃听。您的明文通信是不安全的。有线网络也有被窃听的风险。ARP 电子欺骗攻击者可以获取你的数据包。此外，网络管理员或提供公共 Wi-Fi 的咖啡馆或机场的设施业主可以随时窃听您的通信。即使你在家使用互联网，也有风险，您的 ISP 或电信公司的雇员可能窃听，在线路上偷看您的明文数据包。(事实上，有一个犯罪事件，日本电报电话公司的雇员，在电信大楼进行了窃听。所以，我们永远不能信任 ISP 或电信公司的员工)。&lt;/p&gt;

&lt;p&gt;当在互联网上使用 HTTP、POP3 或 IMAP 纯文本通信时，你无法避免窃听。SSL (HTTPS) 对窃听是安全的，但是大多数网站使用的是 HTTP。HTTP 数据包传输的是纯文本格式。&lt;/p&gt;

&lt;p&gt;最好的是存在这样的方法，对所有到互联网服务器的通信进行自动加密。在这种情况下，没有人可以在本地网络或本地电信大楼偷看你的数据包的内容。&lt;/p&gt;

&lt;h2&gt;VPN 可以加密和转播你的通信&lt;/h2&gt;

&lt;p&gt;如果你在使用互联网时使用 VPN ，可以解决上述这三个问题。&lt;/p&gt;

&lt;h3&gt;解决方案 1: VPN 可以绕过防火墙。&lt;/h3&gt;

&lt;p&gt;由于某些政府防火墙发生的 &quot;未知故障&quot; ，一些海外网站从防火墙后面无法访问，你可以通过海外的 VPN 服务器访问这些网站。海外 VPN 服务器将会把你的通信转到目标 Web 服务器。&lt;/p&gt;

&lt;h3&gt;解决方案 2: VPN 可以隐藏你的真实 IP 地址。&lt;/h3&gt;

&lt;p&gt;当 VPN 连接建立时，所有的通信的源 IP 地址将被替换为中继 VPN 服务器的 IP 地址。这将对你非常有帮助，因为在那一刻没有人再可以轻松地分析和跟踪你的真实 IP 地址了。目标 Web 服务器或 E-mail 的邮件头列表上的 IP 地址日志将被记录，好像通信是通过中继 VPN 服务器发起的。您可以安全地隐藏你的 IP 地址，并且可以发送匿名帖子或电子邮件到网站或邮件服务器。此外，如果您的计算机感染了由 &quot;真正的罪犯&quot; 发送的木马，真正的罪犯发送一个远程操作，让您的电脑发送非法敲诈邮件给某人，你不再处于被执法者错误逮捕的风险中。&lt;/p&gt;

&lt;h3&gt;解决方案 3: VPN 可以防止在本地网络上的窃听&lt;/h3&gt;

&lt;p&gt;如果你总是使用 VPN ，所有通信都将被自动加密。即使你的邻居在本地网络上是个搭线窃听者，你的数据包也不能被他偷看到。&lt;/p&gt;

&lt;h2&gt;VPN Gate 和现有 VPN 服务之间有什么不同 ?&lt;/h2&gt;

&lt;p&gt;如上所述， VPN 可以解决使用互联网中的几个问题。但是，通常你在远程地点 (海外) 至少需要一台物理的 VPN 服务器，实际利用上述 VPN 的功能。&lt;/p&gt;

&lt;p&gt;大多数互联网用户都无法在海外拥有自己的 VPN 服务器。对于这样的用户，一些互联网公司提供了现有的、付费的、共享的 VPN 服务。这样的服务需要用户注册，用信用卡付款，将可以为用户创建一个帐户。用户将获得根据合同的具体条款使用共享 VPN 服务器的权利。&lt;/p&gt;

&lt;p&gt;所以，什么是 VPN Gate 和现有的支付 VPN 服务之间的不同呢 ? 以用户的观点出发，两个似乎是相似的。但是， VPN Gate 与现有的 VPN 服务的差异描述如下。&lt;/p&gt;

&lt;h3&gt;现有共享 VPN 服务的问题&lt;/h3&gt;

&lt;p&gt;现有的 VPN 服务的实施，是供应商公司在数据中心托管的一些 VPN 服务器。在数据中心提供一些共享的 VPN 服务器的这种传统方法有一个问题，即每个 VPN 服务器的 IP 地址都在相同或相似的 IP 地址分配块。因为 IP 地址通常由相同的 ISP 分配。每个 VPN 服务器的 IP 地址是固定的，所以他们很少改变。&lt;/p&gt;

&lt;p&gt;这种共享的 VPN 服务不容忍对 &quot;政府防火墙的未知故障&quot; 。 &quot;政府防火墙的未知故障&quot; ，通常会出现一系列 IP 地址块变成完全无法从该国境内访问的情况。如果 &quot;未知故障&quot; 发生在包含共享的 VPN 服务器群集的 IP 地址块分配的 IP 地址范围，没有群集的 VPN 服务器将无法从该国访问。事实上，最近有报道说，某天一个现有的共享 VPN 服务器的、特定的群集，从一个特定国家的政府防火墙突然无法访问。&lt;/p&gt;

&lt;p&gt;现有共享 VPN 服务的另一个问题是: 带宽占用。现有的共享 VPN 服务器物理放置在特定的数据中心。每个用户的所有通信将集中在数据中心的上行线路的互联网传输线上。所有处理的工作量将集中在数据中心托管的一些共享 VPN 物理服务器上。服务提供商认为在集群中增加 VPN 服务器的数量，或增加互联网传输线路的带宽，但这种扩张需要成本。如果成本增加，这种共享的 VPN 服务的费用将会增加。如果节省成本，这种共享的 VPN 服务的速度将下降。大多数共享的 VPN 服务不能向用户提供优等质量。&lt;/p&gt;

&lt;h3&gt;VPN Gate 学术实验的优点&lt;/h3&gt;

&lt;p&gt;正如你可以看到 VPN Gate 公共 VPN 中继服务器的列表，有很多运行在 VPN Gate 公共 VPN 中继服务器。这些 VPN 服务器没有物理地放置在一个特定的数据中心，也没有一个特定的 IP 地址分配块，他们都是由不同 ISP、在物理地点托管的。&lt;/p&gt;

&lt;p&gt;每个 VPN Gate 公共 VPN 中继服务器是分布式的，并由许多志愿者托管。一名志愿者是拥有一台计算机、保持带宽连接到互联网的人。他是一个同意提供 CPU 时间和带宽、支持 VPN Gate 学术实验的人。你可以成为一名志愿者。&lt;/p&gt;

&lt;p&gt;志愿者在地理上是分布式的。志愿者的 ISP 也是分布式的。所以每一个 VPN 服务器的 IP 地址是分布式的。分配的 IP 地址没有特点。每天志愿者的数量增加或减少，每个 IP 地址每次都改变。如果政府的防火墙出现 &quot;故障&quot; ，整个 VPN Gate 中继服务器不受影响。如果一些 VPN 服务器无法从你的国家访问，你仍然可以访问其他 VPN 服务器。&lt;/p&gt;

&lt;p&gt;因为 VPN Gate 服务器由志愿者托管，每个志愿者花费极少量的带宽成本和 CPU 时间在他的 VPN 服务器上， VPN Gate 服务可以被大家免费使用。免费的意思为任何想要使用 VPN Gate 服务的用户无需注册。&lt;/p&gt;

&lt;p&gt;因此，不同于现有的共享 VPN 服务， VPN Gate 学术实验服务可以无需付费地使用。&lt;/p&gt;

&lt;h3&gt;VPN Gate 网站的镜像服务器&lt;/h3&gt;

&lt;p&gt;一旦一个用户连接 VPN 会话到 VPN Gate 公共 VPN 中继服务器之一，他可以从任何国家获得自由访问互联网。&lt;/p&gt;

&lt;p&gt;然而，如果 www.vpngate.net 网站 (本网站) 无法从他的国家访问，他不能首先获得 VPN Gate 公共 VPN 中继服务器列表。&lt;/p&gt;

&lt;p&gt;所以，我们提供了许多镜像站点的 URL &lt;a href=&quot;https://github.com/waylau/vpngate-mirrors&quot;&gt;https://github.com/waylau/vpngate-mirrors&lt;/a&gt; ，以帮助在这些国家的用户。如果一个用户能获得访问至少一个镜像网站，他可以浏览 VPN Gate 公共 VPN 中继服务器列表页。&lt;/p&gt;

&lt;h2&gt;VPN Gate client 客户端的使用&lt;/h2&gt;

&lt;p&gt;VPN 在 Windows 上的分步指南 (使用 SoftEther VPN)&lt;/p&gt;

&lt;h3&gt;1.安装带 VPN Gate Client 插件的 SoftEther VPN Client (只需在第一次时安装一次)&lt;/h3&gt;

&lt;p&gt;下载带有 &quot;VPN Gate Client 插件&quot; 的 SoftEther VPN Client 的特殊版本。
&lt;a href=&quot;https://github.com/waylau/vpngate-mirrors/&quot;&gt;下载 SoftEther VPN Client + VPN Gate Client 插件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/01_zpse001e011.jpg&quot; alt=&quot;down&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解压缩下载的 ZIP 文件内容到一个文件夹中。如上图，安装程序和一些 DLL 文件被提取。
执行以 &quot;vpngate-client&quot; 开头的文件名的安装程序，并继续进行安装。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/02_zps419f7ea5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/03_zps378a9128.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述安装程序将启动。你必须在 &quot;选择软件组件安装&quot; 屏幕中选择 &quot;SoftEther VPN Client&quot; 。
安装完成后，将在桌面上创建 SoftEther VPN Client 的图标。&lt;/p&gt;

&lt;h3&gt;2.运行 VPN Gate Client 插件并连接到 VPN Gate 服务器&lt;/h3&gt;

&lt;p&gt;在桌面上双击 SoftEther VPN Client 图标。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/04_zpsd1aa9902.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图， &quot;VPN Gate 公共 VPN 中继服务器&quot; 图标会显示在窗口中。双击该图标。
如果有通知显示，继续按屏幕描述的进行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/05_zps3a635181.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&quot;SoftEther VPN Client 的 VPN Gate 学术实验项目插件&quot; 启动。
在此屏幕上，你可以看到当前正在运行的 VPN Gate 公共 VPN 服务器的列表。此屏幕上的列表与 顶页的列表 是相同的。从列表中选择一个连接，然后单击 &quot;连接到 VPN 服务器&quot; 按钮。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/06_zps7a3c07be.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果选定的 VPN Gate 服务器同时支持 TCP 和 UDP 协议，上面的屏幕将会出现。在屏幕上选择 TCP 或 UDP。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/07_zpsdde12094.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一个 VPN 连接建立成功了，上面的消息将出现。这个窗口将在 5 秒后自动消失。如果您无法连接到指定的 VPN 服务器，再试一次。&lt;/p&gt;

&lt;h3&gt;3.通过 VPN 中继享受互联网&lt;/h3&gt;

&lt;p&gt;虽然建立了 VPN 连接，在 Windows 上将创建一个虚拟网络适配器，该适配器将被分配一个以 &quot;10.211&quot; 开始的 IP 地址。默认网关地址将被指定在虚拟网络适配器上。您可以在 Windows 命令提示下运行 &quot;ipconfig / all&quot; 命令，确认这些网络配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/08_zpsb6bd618c.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当 VPN 建立时，所有到互联网的通讯将通过 VPN 服务器转发。您可以在 Windows 命令提示中使用 &quot;tracert 8.8.8.8&quot; 命令验证。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/09_zps19a95efa.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，如果数据包路径是通过 &quot;10.211.254.254&quot; ，你的通信现在就是通过 VPN Gate 公共 VPN 服务器中的一个转发的。
您还可以访问 VPN Gate 顶部页面 来查看当前的全球 IP 地址。如果你连接到一个位于海外国家的 VPN 服务器，您可以看到您的来源国或地区已更改为其他的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/10_zps3b2c9346.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你的 VPN 连接建立时，享受 YouTube、Facebook 或 Twitter 吧。
Facebook、Twitter 和 Gmail 使用 HTTPS (SSL) 加密的通信协议。无论是否通过 VPN ，没有人可以窃听这些加密通信。&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Nov 2014 01:41:00 +0800</pubDate>
        <link>http://www.waylau.com/about-vpngate/</link>
        <guid isPermaLink="true">http://www.waylau.com/about-vpngate/</guid>
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>中国行政区划的英文</title>
        <description>&lt;h2&gt;中国行政区划（administrative division）&lt;/h2&gt;

&lt;p&gt;分为几个级别（government level/level）；宪法（Constitution）规定了三个级别（de jure level），但实际上有五个级别（de facto level/practical level）——33个省级（province/province-level region/province-level division）、333个地区级（prefecture/prefecture-level region/prefecture-level division/second-level division）【非宪法区划】、2862个县级（county/county-level region/county-level division）、41636个乡级（township/township-level region/township-level division）及无数村级（village/village-level region/village-level division）【非宪法区划】行政区。各个级别又有不同名称，下面加以详细讨论【具体数字以2005年统计数据为准】。&lt;/p&gt;

&lt;h2&gt;省级行政区&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;22个省（province）【台湾省也可以叫‘据称’的省份，claimed province】&lt;/li&gt;
&lt;li&gt;五个自治区（autonomous region）&lt;/li&gt;
&lt;li&gt;四个直辖市（municipality/centrally-administered municipality）&lt;/li&gt;
&lt;li&gt;两个特别行政区（special administrative region/SAR）【香港（Hong Kong）与澳门（Macau/Macao）】&lt;/li&gt;
&lt;li&gt;直属（subservient to）中央政府（central government）。省长叫governor。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;地区级行政区&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;17个地区（prefecture）&lt;/li&gt;
&lt;li&gt;30个自治州（autonomous prefecture）【少数民族叫ethnic minority）】&lt;/li&gt;
&lt;li&gt;283个地级市（prefecture-level city）&lt;/li&gt;
&lt;li&gt;三个盟（league）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;县级行政区具&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1464个县（county）&lt;/li&gt;
&lt;li&gt;117个自治县（autonomous county）&lt;/li&gt;
&lt;li&gt;374个县级市（county-level  city）&lt;/li&gt;
&lt;li&gt;852个市辖区（district）&lt;/li&gt;
&lt;li&gt;49个旗（banner）&lt;/li&gt;
&lt;li&gt;三个自治旗（autonomous banner）&lt;/li&gt;
&lt;li&gt;一个林区（forestry area）&lt;/li&gt;
&lt;li&gt;两个特区（special district）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;乡级行政区&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;14677个乡（township）&lt;/li&gt;
&lt;li&gt;1092个民族乡（ethnic township）&lt;/li&gt;
&lt;li&gt;19522个镇（town）&lt;/li&gt;
&lt;li&gt;6152个街道办事处（subdistrict）&lt;/li&gt;
&lt;li&gt;11个区公所（district public office）&lt;/li&gt;
&lt;li&gt;181个苏木（sumu）&lt;/li&gt;
&lt;li&gt;一个民族苏木（ethnic sumu）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;村级行政区&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;80717个社区居民委员会（neighborhood committee）【社区叫neighborhood或community）】&lt;/li&gt;
&lt;li&gt;623669个村民委员会（village committee）或村民小组（village group）【包括行政村（administrative village）和自然村（natural village）】。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;特殊情况&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;副省级城市（sub-provincial city）&lt;/li&gt;
&lt;li&gt;副地级市（sub-prefecture-level city）&lt;/li&gt;
&lt;li&gt;副省级城市辖区（sub-provincial district）【如上海的浦东和天津的滨海】。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;其他&lt;/h2&gt;

&lt;p&gt;中国又可以分为几个大区，但不是严格的行政区划：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;华东（East China）&lt;/li&gt;
&lt;li&gt;东北（Northeast China）&lt;/li&gt;
&lt;li&gt;华北（North China）&lt;/li&gt;
&lt;li&gt;中南（South Central China）&lt;/li&gt;
&lt;li&gt;华中（Central China）&lt;/li&gt;
&lt;li&gt;华南（Southern China/South China）&lt;/li&gt;
&lt;li&gt;西部（Western China）&lt;/li&gt;
&lt;li&gt;西北（Northwest China）&lt;/li&gt;
&lt;li&gt;西南（Southwest China）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;em&gt;参考：&lt;/em&gt;&lt;a href=&quot;http://www.24en.com/column/Khubilai/2010-08-31/119131.html&quot;&gt;http://www.24en.com/column/Khubilai/2010-08-31/119131.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Nov 2014 01:41:00 +0800</pubDate>
        <link>http://www.waylau.com/chinese-administrative-division/</link>
        <guid isPermaLink="true">http://www.waylau.com/chinese-administrative-division/</guid>
        
        <category>english</category>
        
      </item>
    
      <item>
        <title>WebSocket 和 Golang 实现聊天功能</title>
        <description>&lt;p&gt;这个示例应用程序展示了如何使用 &lt;a href=&quot;http://tools.ietf.org/html/rfc6455&quot;&gt;WebSocket&lt;/a&gt;, &lt;a href=&quot;http://golang.org/&quot;&gt;Golang&lt;/a&gt; 和  &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 创建一个简单的web聊天应用程序。这个示例的源代码在 &lt;a href=&quot;https://github.com/waylau/goChat&quot;&gt;https://github.com/waylau/goChat&lt;/a&gt; 。&lt;/p&gt;

&lt;h2&gt;Running the example 运行示例&lt;/h2&gt;

&lt;p&gt;这个示例需要 Golang 开发环境。 该&lt;a href=&quot;http://golang.org/doc/install.html&quot;&gt;页面&lt;/a&gt;描述如何安装开发环境。&lt;/p&gt;

&lt;p&gt;一旦你去启动和运行,您可以下载、构建和运行的例子, 使用命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get gary.burd.info/go-websocket-chat
go-websocket-chat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在支持 websocket 的浏览器尝试打开 &lt;a href=&quot;http://127.0.0.1:8080/&quot;&gt;http://127.0.0.1:8080/&lt;/a&gt; 启动应用&lt;/p&gt;

&lt;h2&gt;Server 服务器&lt;/h2&gt;

&lt;p&gt;服务器程序实现了 &lt;a href=&quot;http://golang.org/pkg/net/http/&quot;&gt;http&lt;/a&gt; 包，包含了 Go 分发和 Gorilla 项目的 websocket 包.&lt;/p&gt;

&lt;p&gt;应用程序定义了两种类型, connection 和 hub 。服务器为每个 webscocket 连接 创建的一个 connection 类型的实例 。 连接器扮演了 websocket 和 hub 类型单例 之间的媒介 。 hub 保持一组注册了的连接器 和 广播到连接器的信息。&lt;/p&gt;

&lt;p&gt;程序运行了一个 goroutine 给 hub ,两个 goroutine 给每个连接器。 goroutine 通过 channel 和其他进行交流。 hub 拥有注册连接器、注销连接器和广播信息的 channel。一个连机器拥有缓存的发出信息的 channel 。其中一个 连接器的 goroutine 从这个 channel 中读信息 并把信息写入 webscoket。另外一个连接器 goroutine 从 websocket  读信息，并把信息发送到 hub。&lt;/p&gt;

&lt;p&gt;下面是 hub 类型代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

type hub struct {
    // 注册了的连接器
    connections map[*connection]bool

    // 从连接器中发入的信息
    broadcast chan []byte

    // 从连接器中注册请求
    register chan *connection

    // 从连接器中注销请求
    unregister chan *connection
}

var h = hub{
    broadcast:   make(chan []byte),
    register:    make(chan *connection),
    unregister:  make(chan *connection),
    connections: make(map[*connection]bool),
}

func (h *hub) run() {
    for {
        select {
        case c := &amp;lt;-h.register:
            h.connections[c] = true
        case c := &amp;lt;-h.unregister:
            if _, ok := h.connections[c]; ok {
                delete(h.connections, c)
                close(c.send)
            }
        case m := &amp;lt;-h.broadcast:
            for c := range h.connections {
                select {
                case c.send &amp;lt;- m:
                default:
                    delete(h.connections, c)
                    close(c.send)
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用程序的 主要 函数启动 hub 以 goroutine 形式运行方法。连接器 发送请求到 hub 通过 注册、注销和广播 channel。&lt;/p&gt;

&lt;p&gt;hub 注册连接器通过添加 connection 的指针作为 connections map 的主键。这个  map 的值通常是 true。&lt;/p&gt;

&lt;p&gt;注销的代码有点复杂。除了从 connections map 删除连接器的指针外,  hub 关闭了 connection 的发送，来标识没有信息再被发送到 connection了。&lt;/p&gt;

&lt;p&gt;hub 通过循环注册连接器和发送信息到连接器的发送 channel 来控制信息。 如果连接器的发送缓冲区已经满了，那么  hub 假设 客户端已死或卡住了。这种情况下, hub 注销连接器 并关闭 websocket.&lt;/p&gt;

&lt;p&gt;下面关于 connection 类型的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &quot;github.com/gorilla/websocket&quot;
    &quot;net/http&quot;
)

type connection struct {
    // websocket 连接器
    ws *websocket.Conn

    // 发送信息的缓冲 channel 
    send chan []byte
}

func (c *connection) reader() {
    for {
        _, message, err := c.ws.ReadMessage()
        if err != nil {
            break
        }
        h.broadcast &amp;lt;- message
    }
    c.ws.Close()
}

func (c *connection) writer() {
    for message := range c.send {
        err := c.ws.WriteMessage(websocket.TextMessage, message)
        if err != nil {
            break
        }
    }
    c.ws.Close()
}

var upgrader = &amp;amp;websocket.Upgrader{ReadBufferSize: 1024, WriteBufferSize: 1024}

func wsHandler(w http.ResponseWriter, r *http.Request) {
    ws, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        return
    }
    c := &amp;amp;connection{send: make(chan []byte, 256), ws: ws}
    h.register &amp;lt;- c
    defer func() { h.unregister &amp;lt;- c }()
    go c.writer()
    c.reader()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wsHandler 方法被主函数当做&lt;a href=&quot;http://golang.org/pkg/net/http/#Handler&quot;&gt;http handler&lt;/a&gt;注册。HTTP 连接到 WebSocket 协议的升级，创建一个连接对象，注册这个连接到 sub ,并通过 &lt;a href=&quot;http://weekly.golang.org/doc/effective_go.html#defer&quot;&gt;defer&lt;/a&gt;延迟语句 来控制 连接的注销。&lt;/p&gt;

&lt;p&gt;接着，wsHandler 方法开启 连接器的写入方法作为一个 goroutine。 写入方法将信息从连接器的 channel 转入 websocket。当 hub 关闭 channel 或者 在写入 websocket 时出错，写入方法关闭。&lt;/p&gt;

&lt;p&gt;最后，wsHandler 方法 调用连接器的 读 方法。 读方法将 入站消息 从 websocket 转到 hub。&lt;/p&gt;

&lt;p&gt;这里是服务器的代码的其余部分:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &quot;flag&quot;
    &quot;go/build&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;path/filepath&quot;
    &quot;text/template&quot;
)

var (
    addr      = flag.String(&quot;addr&quot;, &quot;:8080&quot;, &quot;http service address&quot;)
    assets    = flag.String(&quot;assets&quot;, defaultAssetPath(), &quot;path to assets&quot;)
    homeTempl *template.Template
)

func defaultAssetPath() string {
    p, err := build.Default.Import(&quot;gary.burd.info/go-websocket-chat&quot;, &quot;&quot;, build.FindOnly)
    if err != nil {
        return &quot;.&quot;
    }
    return p.Dir
}

func homeHandler(c http.ResponseWriter, req *http.Request) {
    homeTempl.Execute(c, req.Host)
}

func main() {
    flag.Parse()
    homeTempl = template.Must(template.ParseFiles(filepath.Join(*assets, &quot;home.html&quot;)))
    go h.run()
    http.HandleFunc(&quot;/&quot;, homeHandler)
    http.HandleFunc(&quot;/ws&quot;, wsHandler)
    if err := http.ListenAndServe(*addr, nil); err != nil {
        log.Fatal(&quot;ListenAndServe:&quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用主程序启动 hub goroutine。 接着 主程序 注册 主页 和 websocket 连接器的控制器N。最后主程序启动 HTTP 服务器。&lt;/p&gt;

&lt;h2&gt;Client 客户端&lt;/h2&gt;

&lt;p&gt;客户端的实现是一个简单的 HTML 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Chat Example&amp;lt;/title&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {

    var conn;
    var msg = $(&quot;#msg&quot;);
    var log = $(&quot;#log&quot;);

    function appendLog(msg) {
        var d = log[0]
        var doScroll = d.scrollTop == d.scrollHeight - d.clientHeight;
        msg.appendTo(log)
        if (doScroll) {
            d.scrollTop = d.scrollHeight - d.clientHeight;
        }
    }

    $(&quot;#form&quot;).submit(function() {
        if (!conn) {
            return false;
        }
        if (!msg.val()) {
            return false;
        }
        conn.send(msg.val());
        msg.val(&quot;&quot;);
        return false
    });

    if (window[&quot;WebSocket&quot;]) {
        conn = new WebSocket(&quot;ws:///ws&quot;);
        conn.onclose = function(evt) {
            appendLog($(&quot;&amp;lt;div&amp;gt;&amp;lt;b&amp;gt;Connection closed.&amp;lt;/b&amp;gt;&amp;lt;/div&amp;gt;&quot;))
        }
        conn.onmessage = function(evt) {
            appendLog($(&quot;&amp;lt;div/&amp;gt;&quot;).text(evt.data))
        }
    } else {
        appendLog($(&quot;&amp;lt;div&amp;gt;&amp;lt;b&amp;gt;Your browser does not support WebSockets.&amp;lt;/b&amp;gt;&amp;lt;/div&amp;gt;&quot;))
    }
    });
&amp;lt;/script&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
html {
    overflow: hidden;
}

body {
    overflow: hidden;
    padding: 0;
    margin: 0;
    width: 100%;
    height: 100%;
    background: gray;
}

#log {
    background: white;
    margin: 0;
    padding: 0.5em 0.5em 0.5em 0.5em;
    position: absolute;
    top: 0.5em;
    left: 0.5em;
    right: 0.5em;
    bottom: 3em;
    overflow: auto;
}

#form {
    padding: 0 0.5em 0 0.5em;
    margin: 0;
    position: absolute;
    bottom: 1em;
    left: 0px;
    width: 100%;
    overflow: hidden;
}

&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;log&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;form id=&quot;form&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Send&quot; /&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;msg&quot; size=&quot;64&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端使用 &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文档加载。脚本检查 websocket 的功能 。如果 WebSocket 功能 可以用，然后打开脚本与服务器的连接，并注册一个回调处理来自服务器的信息。回调使用 appendlog 方法将消息添加到聊天记录。&lt;/p&gt;

&lt;p&gt;appendlog 方法检查在添加新的内容时的滚动位置，从而可以让用户手动滚动聊天记录而不会被新来的消息中断。如果聊天记录滚动至底部，那么新内容添加的到旧内容的后面。否则，滚动的位置不会改变。&lt;/p&gt;

&lt;p&gt;表单处理器将用户的输入写入到 WebSocket 并且清除输入字段。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考：&lt;/em&gt;&lt;a href=&quot;http://gary.burd.info/go-websocket-chat&quot;&gt;http://gary.burd.info/go-websocket-chat&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Nov 2014 01:41:00 +0800</pubDate>
        <link>http://www.waylau.com/go-websocket-chat/</link>
        <guid isPermaLink="true">http://www.waylau.com/go-websocket-chat/</guid>
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>最大化兼容 html5 视频</title>
        <description>&lt;p&gt;HTML5 在 web 页面使用 video 元素呈现视频。但 HTML5 视频并不是最终的解决方案,它不能在所有的浏览器工作。你知道 HTML5 视频真的在网上工作吗? 你担心 HMTL5 视频兼容性吗? 看看这篇文章的建议和解决方案如何最大化 HMTL5 视频兼容性。&lt;/p&gt;

&lt;p&gt;正如我们所知, web 页面上显示一个视频或电影是没有行业标准的。除了浏览器自身,大多数网站显示视频通过浏览器插件,比如 Flash player。 HTML5 包含一个 video 元素将视频嵌入到web页面。W3C因此引入了在互联网上显示视频的新标准 HTML5 video 元素。 使用HTML5视频没有限制视频编解码器,音频编解码器,或容器格式。为了获得最大的 HMTL5 视频兼容性,可以链接到多个视频文件在一个 video 元素里,用户的浏览器将选择第一个视频文件,它可以自动播放。&lt;/p&gt;

&lt;p&gt;这是最近的HTML5视频:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Internet Explorer 8 没有 HTML5 视频支持,但几乎所有的 IE 用户都有 Adobe Flash 插件。 在本章的后面,我将向您展示如何使用 HTML5视频优雅地转回到 Flash。&lt;/li&gt;
&lt;li&gt;Internet Explorer 9 支持所有的 H.264 视频和 AAC 或 MP3 音频在一个 MP4 容器里。 它也将播放 WebM 视频如果你安装一个第三方的编解码器,假如默认没有在任何版本的 Windows 安装的话。 IE9 不支持其他第三方编解码器(不像 Safari 可以支持播放 QuickTime 可播放的格式)。&lt;/li&gt;
&lt;li&gt;Mozilla Firefox(3.5及以后)支持 Theora 视频和 Vorbis音频在一个 Ogg 容器里。火狐4还支持 WebM。&lt;/li&gt;
&lt;li&gt;Google Chrome(3.0及以后)支持 Theora 视频和 Vorbis音频在一个 Ogg 容器里。 Google Chrome 6.0 还支持 WebM。&lt;/li&gt;
&lt;li&gt;Opera(10.5及以后)支持 Theora 视频和 Vorbis音频在一个 Ogg 容器里。 Opera 10.60 还支持 WebM。&lt;/li&gt;
&lt;li&gt;Safari 在 mac 电脑和 Windows 电脑(3.0及以后)将支持任何QuickTime 所支持的格式。 理论上,您可能需要用户安装第三方QuickTime 插件。 在实践中,很少有用户会这样做。 所以你剩下的格式将会是 QuickTime 开箱即用的支持。 这是一长列表,但不包括WebM,Theora,Vorbis,或 Ogg 容器。 然而, QuickTime 提供支持 H.264 视频(主要配置文件)和 AAC 音频在 MP4 容器里。&lt;/li&gt;
&lt;li&gt;Adobe Flash(9.0.60.184后来)支持  H.264 视频(所有配置文件)和AAC 音频(所有资料)在 MP4 容器里。
手机像苹果的 iPhone 和谷歌的 Android 手机支持 H.264 视频(基线配置)和 AAC 音频(“低复杂度”)在 MP4 容器里。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;你会发现没有单一的容器和编解码器能在所有 HTML5 浏览器工作。 由于许可和其他问题,在不久的将来这是不可能改变。&lt;/p&gt;

&lt;p&gt;你可以参考这篇文章: &lt;a href=&quot;http://www.html5videoplayer.net/html5video/html5-video-browser-compatibility/&quot;&gt;HTML5视频浏览器兼容性问题和解决方案&lt;/a&gt; !&lt;/p&gt;

&lt;p&gt;对于最大的兼容性,可以遵循你的HTML5视频工作波形工作流。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;让你的视频的一个版本,使用 WebM (VP8 + Vorbis) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建第二个版本,使用 H.264 视频(基线)和 AAC 音频(“低复杂度”)在 MP4 容器里。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三个版本,使用 Theora 视频和 Vorbis音频在一个 Ogg 容器里。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接到所有三个视频文件在一个 video 元素里。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;
    &amp;lt;video controls=&quot;controls&quot; poster=&quot;http://www.html5videoplayer.net/poster/toystory.jpg&quot; width=&quot;640&quot; height=&quot;360&quot;&amp;gt;
        &amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.mp4&quot; type=&quot;video/mp4&quot; /&amp;gt;
        &amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.ogv&quot; type=&quot;video/ogg&quot; /&amp;gt;
        &amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.webm&quot; type=&quot;video/webm&quot; /&amp;gt;
    &amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;p&gt;&lt;video controls=&quot;controls&quot; poster=&quot;http://www.html5videoplayer.net/poster/toystory.jpg&quot; width=&quot;640&quot; height=&quot;360&quot;&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.mp4&quot; type=&quot;video/mp4&quot; /&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.ogv&quot; type=&quot;video/ogg&quot; /&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;/video&gt;&lt;/p&gt;

&lt;p&gt;最大化 HTML5 视频兼容所有浏览器,您也可以 嵌套 Flash 的 object 元素从 video 元素中 回退。 你甚至可以包括不同的 HTML5 本地视频的下载链接。&lt;/p&gt;

&lt;p&gt;通过结合 HTML5 和 Flash,你应该能够得到的最大 HMTL5 视频兼容性在几乎所有的浏览器和设备中。 不要忘记,即使所有这些不工作,你仍然可以直接下载链接为HTML5的本地视频。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考：&lt;/em&gt;&lt;a href=&quot;http://www.html5videoplayer.net/html5video/maximize-hmtl5-video-compatibility/&quot;&gt;http://www.html5videoplayer.net/html5video/maximize-hmtl5-video-compatibility/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Nov 2014 01:41:00 +0800</pubDate>
        <link>http://www.waylau.com/maximize-hmtl5-video-compatibility/</link>
        <guid isPermaLink="true">http://www.waylau.com/maximize-hmtl5-video-compatibility/</guid>
        
        <category>html5</category>
        
      </item>
    
      <item>
        <title>嵌入视频到 html5 页面</title>
        <description>&lt;p&gt;HTML5 的到来之前,每个视频的播放都需要通过 web 浏览器中通过第三方浏览器插件。最初我们亲眼目睹 RealPlayer，接着是 Windows Media Player 和 QuickTime, 现在是 Flash,这是目前主导的插件,播放大量的网络视频。&lt;/p&gt;

&lt;p&gt;HTML5 引入了一个新的标准在 web 页面中嵌入和播放视频,无任何第三方插件,只需使用一个视频元素。 似乎是容易的,对吗? 但是你会发现没有这样的一个视频格式,适用于目前所有 HTML5 web 浏览器。&lt;/p&gt;

&lt;p&gt;最大兼容浏览器 HTML5 视频,我们推荐你的视频编码转成如下HTML5视频格式，并在将它们嵌入到你的网页。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;H.264(Baseline) 在 mp4 容器。&lt;/li&gt;
&lt;li&gt;VP8/WEBM 在 webm 容器。&lt;/li&gt;
&lt;li&gt;Theroa/Vorbis 在 ogv 容器。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果你只有一个 HTML5 视频文件嵌入到网页,您可以简单地链接到它的 src 属性&lt;/p&gt;

&lt;h2&gt;Embed HTML5 video single source 嵌入单一来源视频&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;video src=&quot;samplevideo.webm&quot; width=&quot;640&quot; height=&quot;480&quot; autoplay&amp;gt;&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Embed HTML5 video multiple sources 嵌入多来源视频&lt;/h2&gt;

&lt;p&gt;多个视频上面所提到的,是为了最大的 HTML5 视频浏览器兼容性，我们需要3个不同版本的视频。 您可以在web页面中嵌入多个 HTML5 视频在HTML5 视频元素,例子:&lt;/p&gt;

&lt;p&gt;源代码详见下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;video width=&quot;640&quot; height=&quot;360&quot; controls&amp;gt;
&amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.mp4&quot; type=&quot;video/mp4&quot; /&amp;gt;
&amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.webm&quot; type=&quot;video/webm&quot; /&amp;gt;
&amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.ogv&quot; type=&quot;video/ogg&quot; /&amp;gt;
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下
&lt;video width=&quot;640&quot; height=&quot;360&quot; controls&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.mp4&quot; type=&quot;video/mp4&quot; /&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.ogv&quot; type=&quot;video/ogg&quot; /&gt;
&lt;/video&gt;&lt;/p&gt;

&lt;h2&gt;HTML5 video with poster image 添加海报图片&lt;/h2&gt;

&lt;p&gt;现在,让我们去将海报图片添加到HTML5视频。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;video poster=&quot;http://www.html5videoplayer.net/poster/toystory.jpg&quot; width=&quot;640&quot; height=&quot;360&quot; controls&amp;gt;
&amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.mp4&quot; type=&quot;video/mp4&quot; /&amp;gt;
&amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.webm&quot; type=&quot;video/webm&quot; /&amp;gt;
&amp;lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.ogv&quot; type=&quot;video/ogg&quot; /&amp;gt;
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下&lt;/p&gt;

&lt;p&gt;&lt;video poster=&quot;http://www.html5videoplayer.net/poster/toystory.jpg&quot; width=&quot;640&quot; height=&quot;360&quot; controls&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.mp4&quot; type=&quot;video/mp4&quot; /&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;source src=&quot;http://www.html5videoplayer.net/videos/toystory.ogv&quot; type=&quot;video/ogg&quot; /&gt;
&lt;/video&gt;&lt;/p&gt;

&lt;h2&gt;HTML5 video autoplay 视频自动播放&lt;/h2&gt;

&lt;p&gt;如何播放 HTML5 视频? 只需添加 autoplay=”autoplay” 或简单的autoplay 到 video 标签即可。 如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;video autoplay=&quot;autoplay&quot; poster=&quot;http://www.html5videoplayer.net/poster/toystory.jpg&quot; width=&quot;640&quot; height=&quot;360&quot; controls&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;video poster=&quot;http://www.html5videoplayer.net/poster/toystory.jpg&quot; width=&quot;640&quot; height=&quot;360&quot; autoplay controls&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果详见下表&lt;/p&gt;

&lt;p&gt;&lt;video poster=&quot;http://www.html5videoplayer.net/poster/toystory.jpg&quot; width=&quot;640&quot; height=&quot;360&quot; autoplay controls&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考：&lt;/em&gt;&lt;a href=&quot;http://www.html5videoplayer.net/html5video/embed-html5-video-into-web-pages/&quot;&gt;http://www.html5videoplayer.net/html5video/embed-html5-video-into-web-pages/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Nov 2014 01:40:00 +0800</pubDate>
        <link>http://www.waylau.com/embed-html5-video-into-web-pages/</link>
        <guid isPermaLink="true">http://www.waylau.com/embed-html5-video-into-web-pages/</guid>
        
        <category>html5</category>
        
      </item>
    
      <item>
        <title>互联网带来的十大警示</title>
        <description>&lt;p&gt;摘自《周鸿祎自述：我的互联网方法论》&lt;/p&gt;

&lt;h2&gt;1、没人能打败趋势&lt;/h2&gt;

&lt;p&gt;还在几年前，电商会不会冲击实体店这个问题大家还在争论不休。有的人说，实体店有自己的优势，顾客可以现场对物品进行感知，在这点上电商比不了。结果，最终大家发现，实体店变成了体验店，顾客进来进行感知，没错。他觉得货不错，记下型号来，转头就在电商上下订单了。前一段时间，滴滴打车和快的打车两个软件打起来了，不仅免费，而且还倒贴钱。这个现象对一些传统的脑子来说，实在是无法理解、不可理喻，但它就是这么现实地发生了。等到你回过味儿来，再说“不行，我们要转型了”，这时候，你会发现人家已经遥遥领先了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;任何企业都可以找最强的竞争对手打，但有一个对手你是打不过的，那就是趋势&lt;/code&gt;。趋势一旦爆发，就不会是一种线性的发展。&lt;code&gt;它会积蓄力量于无形，最后突然爆发出雪崩效应。任何不愿意改变的力量都会在雪崩面前被毁灭，被市场边缘化&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;2、火鸡的复活节总会到来&lt;/h2&gt;

&lt;p&gt;《黑天鹅》里面有个故事，是讲火鸡的幸福指数，让我感受非常深。&lt;/p&gt;

&lt;p&gt;假设你是一只火鸡，被农夫养在美国的农场。在过去的120天里，你都很幸福，因为农夫每天都给你吃的。所以，随着时间的推移，你的幸福指数直线上升，是线性发展的。绝大多数人都会像这只火鸡一样，站在过去看现在，站在现在预测未来。作为一只火鸡，你认为这种幸福会永远地延续下去。但很不幸，明天就是复活节了，大家知道会发生什么事。火鸡的幸福指数戛然而止，因为火鸡不知道要过复活节，复活节人们要烤火鸡吃。&lt;/p&gt;

&lt;p&gt;很多时候，我就像《皇帝的新装》里的小男孩儿，说了真话，但大家不相信。有一次，中国移动内部开会请我去演讲，讲完了之后，移动的领导就说：谁请周鸿祎来的？以后再也不要请他来讲话了，简直是打击我们的士气。这还是两年前的事，微信刚刚开始起步。这种手机聊天软件发文本免费，对于运营商的短信来讲，这本身就是一个免费的撒手锏。此外，微信发送图片信息不仅免费，而且体验比彩信要好得多。彩信这种产品存在已经十多年了，但如果朋友发给你一条彩信，不仅下载慢，而且还经常打不开，即使打开了，字体可能太小你根本看不清楚。微信用了两年时间，基本上中国的智能手机人手一部，今天电信运营商已经感受到微信的威胁了。对运营商来说，微信就是一只黑天鹅，因为在此之前短信免费、彩信免费根本不可思议，是不可能的。然而，&lt;code&gt;黑天鹅一旦出现，运营商就可能成为一只火鸡，如果不进行转型，如果在产品体验上不能改进，那么即使明天不是复活节，总有一天复活节也会到来&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;3、传统商业模式最终会被边缘化&lt;/h2&gt;

&lt;p&gt;互联网已经干掉了很多行业。它是一个价值的创造者，但它首先是一个价值的毁灭者，它在毁灭很多传统的商业模式，谁离互联网最近，互联网就先毁灭谁。在毁灭的同时，它再去建立新的商业模式。但请读者们不要误会，我这里说的“毁灭”是一个形象的比喻，并不是真的把你彻底消灭了，而是说你被边缘化了，你的收入不再上升了，你的商业价值和商业地位在萎缩。&lt;/p&gt;

&lt;p&gt;比如，我曾经在一些场合说互联网摧毁了报纸，我立马就成了千夫所指的对象。总编们纷纷表示：我们还活得好好的，报纸还能卖，还有广告收入。但你看，无论你在电梯里，还是在地铁里，几乎每个人都拿着一部手机在看新闻，而不像10年前人手一份报纸在读。&lt;/p&gt;

&lt;p&gt;同样，3年后电视台一定会有紧迫感。今天的《爸爸去哪儿》《中国好声音》，看起来好像是一个节目组还必须依托于一个电视台，但中国的年青一代已经不看电视了，他们看什么都在网上看。我预计电视机的开机率会进一步下降，即使智能电视都很难对抗人类贪图便宜、方便的本性，因为人们坐在床边看手机，坐在马桶上看平板电脑，都比看电视更方便。将来出了一档很好的节目，它会直接跟优酷或者爱奇艺合作，观众很快会有上亿，节目的制作人可以直接分享广告收入。一旦这种趋势形成，电视台的意义何在呢？&lt;/p&gt;

&lt;h2&gt;4、失去用户是自取灭亡&lt;/h2&gt;

&lt;p&gt;2006年，几乎所有的互联网公司都在做流氓软件，就360出来革流氓软件的命。当时360是行业攻击对象，但用户欢迎360。当时行业大佬们把我骂得狗血喷头，我以为我要被他们骂死了，连篇的大字报、檄文发到网上，就差登我的绯闻和裸照了。但2006年给了我一条最深刻的经验是，我发现用户是有辨别力的，只要你做了对用户有用的事情，解决了用户的问题，用户就会支持你。&lt;code&gt;只要用户支持你，你就不用担心你的公司会死掉&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我强调用户体验为王，重视用户，用户至上，这都不是大口号。只要干互联网行业，你一定要把用户放在第一位，伺候好用户，让用户满意。无论别人怎么给你泼冷水，骂你，只要用户相信你，你都有机会。相反，如果你的产品做不好，不能为用户解决问题，失去了用户，那别人不用骂你你自己就死菜了。&lt;/p&gt;

&lt;p&gt;不管是别人请我做演讲，还是来采访我，我都会强调一个公司要想在互联网上成功，就一定要尊重用户体验。作为安全软件，360不仅要尊重用户体验，而且要保护用户利益。有人说：周鸿祎你净喊一些高大上的口号，你不知道现在“为人民服务”、“用户至上”之类的口号都过时了吗？我觉得正相反，我们这些做互联网的，得时刻想着满足用户需求，为用户服务。因为道理很简单，&lt;code&gt;用户基数是所有互联网模式的基础，如果产品做不好，服务做不好，用户用鼠标一点就跑了，那你设计的商业模式再牛，也肯定是一分钱都挣不到&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;5、不要藐视新生事物&lt;/h2&gt;

&lt;p&gt;今天，几乎每个人都能感觉到互联网的革命性力量，每个人都在谈论互联网思维。但是大家想一想，今天互联网的排山倒海之势，颠覆一切商业游戏规则的力量，是一夜之间发生的吗？不是，所有的颠覆式创新都不是敲锣打鼓来的，而是隐藏在一片噪声里。它是代表未来趋势的一个信号，但你却通常看不到、看不懂、看不清。&lt;/p&gt;

&lt;p&gt;所以，一定不能以一种藐视的态度看待新生事物。它可能满身缺点，你用自己的优点比它的缺点，基本上你会全胜。但是，颠覆你的这个东西，不需要做成十项全能，它只要在一个点上追求极致，做得远远超过你，这就足够了。不要小看这些细节，任何颠覆性的创新都是从细节入手，从不起眼的地方出发，不断纠正自己的缺点，不断地完善。当有一天你注意到它的时候，你已经无法抵挡它的颠覆性力量了。&lt;/p&gt;

&lt;h2&gt;6、硬件趋向免费制造业必须转型&lt;/h2&gt;

&lt;p&gt;如果你只会生产硬件、卖硬件，一旦你的价值链被人免费，对不起，你最后只能沦为代工，挣点微薄的利润。要想生存下去，你需要建立一种新的商业模式，要创造新的价值链。所以，“硬件免费”必须要创造新的价值链来支撑，这也是传统企业转型互联网时必须要考虑的问题。&lt;/p&gt;

&lt;p&gt;硬件免费之后，如同免费的软件一样，不再是一个价值链里唯一的一环，而是变成了第一环，变成了厂商和用户之间交互的窗口，变成了厂商与用户沟通的桥梁。用户用了我的冰箱、开了我的车、看了我的电视之后，我们还能不断地给他提供其他的服务来赚钱。&lt;/p&gt;

&lt;p&gt;硬件免费，我认为不会立马发生，但在下一个5年会看到这个趋势。今天，&lt;code&gt;在互联网上凡是懂得免费之道的企业，都会比较容易在这次新的浪潮中弯道超车&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;7、细节不足毁掉整个用户体验&lt;/h2&gt;

&lt;p&gt;比如，飞机头等舱很贵，但餐饮却令人难以下咽。如果能在餐饮上有所改进，哪怕机票涨个几十块钱，也会收到意想不到的效果。很多企业不关注这种细节，最后就失去了用户。如果留心观察，你会发现很多时候细节在别人注意不到的地方。你如果能够找到与众不同的力量，你就能够创造出超出预期的产品。&lt;/p&gt;

&lt;p&gt;但是一个细节上的不足，就把下大力气花大成本在电视、报刊上投放的品牌广告给毁掉了。我也住过一些星级酒店，四五千一晚，但上网还要单花200块钱。可能酒店觉得大客户都不在乎花四五千住一个套间，为什么吝啬200块钱的上网费呢？可是我发现每次上网不免费，就体验不好，这就是细节。同样，你请朋友吃饭，花了2 000块钱，但餐巾纸却要两块钱一包，你也会感觉非常不好。&lt;code&gt;这不能用逻辑来做解释，就是一种消费的心理，也是用户的心理&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;8、不为用户创造价值的企业，商业价值也是短暂的&lt;/h2&gt;

&lt;p&gt;判断一个公司是否伟大，不在于它创造了多少市值，产生了多少千万富翁、亿万富翁，而在于给顾客创造了多大的价值。在国内，有些企业是靠给用户制造问题，而不是通过解决问题来赚钱。比如在一些城市，你一坐上出租车，前排座位后面挂着的液晶屏就开始播放刺眼、刺耳的广告，而且还关不掉。8年前，绝大多数增值服务提供商通过给客户设计陷阱乱扣费来赚钱，有的竟然还上市了。但事实证明，不为用户创造价值的企业，即使能获得商业价值，也是短暂的。&lt;/p&gt;

&lt;h2&gt;9、平台战略害死人&lt;/h2&gt;

&lt;p&gt;互联网里的平台都不是做出来的，都是积累起来的，是在为用户服务的过程中形成的，最开始都是从一个点做起。如果在2006年360按照安全平台的思维去做，肯定早就死掉了，因为要成为一个平台，要做的东西太多。按照平台思维去做，你可能做不出来，可能需要的时间很长，可能到最后也没有形成自己的突破点。&lt;/p&gt;

&lt;p&gt;如果你今天手里有1亿人，就很容易取得成功，就像腾讯有用户，插根扁担都开花，而其他人种树苗怎么浇水都不行，因为没有土壤。所以当你有了足够的用户，就可以随心所欲地建立自己的商业模式。最关键的是在你没有用户的时候，用什么微创新的点切入。&lt;/p&gt;

&lt;p&gt;所以很多企业是被平台战略害死的，因为平台战略给领导做报告特别好听，特别宏大，特别符合中国人的概念。但最大的问题是消费者不买账，消费者不会因为360通过了一个无线平台战略，开了一个无线平台战略发布会，就选择你的商品。消费者永远会问你一个问题：我上你的网站，装你的软件，你解决我的什么问题？&lt;/p&gt;

&lt;h2&gt;10、以发财为目标形不成好团队&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;好的团队，不能以发财为目标，一定要有某种程度的理想主义情怀&lt;/code&gt;。我在互联网行业里干了十多年，从来没有看到一个为了解决财务问题而凑在一起的团队能够最终走向成功的。相反，这样的团队一旦遭遇到了挫折，就容易悲观失望；或者一旦外面有更大的现实利益诱惑，团队容易分崩离析。前不久，我找人力资源的人帮我统计了一下，看一看跟我合作在十年以上，在八年以上，在五年以上的到底有哪些同事。在这一批人里，有我第一次创业时开始就跟着我一起打拼的；有的在方正时是同事，后来我做3721的时候加入进来；还有的是加入到我在雅虎时的团队，中间离开几年，后来又加入到360来的。看了这个名单，我很感慨，如果那时候我跟他们说，出来跟我干吧，到时候发财了咱们大碗喝酒，大口吃肉，大秤分金，我估计他们也不会跟我合作这么长时间。相反，我们的目标是要做出牛的互联网产品来，让人们的互联网生活更方便、更安全，有了这个目标，大家才能持之以恒地走下来。&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 01:40:00 +0800</pubDate>
        <link>http://www.waylau.com/top-10-warning-that-internet-brings/</link>
        <guid isPermaLink="true">http://www.waylau.com/top-10-warning-that-internet-brings/</guid>
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>简单描述各个流行软件开源许可</title>
        <description>&lt;p&gt;千言不如一图&lt;/p&gt;

&lt;p&gt;英文原图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/open-source-licenses-en_zps6ed423c7.png&quot; alt=&quot;英文原图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中文翻译&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1288.photobucket.com/albums/b484/waylau/waylau%20blog/open-zh_zps559a48ab.jpg&quot; alt=&quot;中文翻译&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://paulmillr.com/posts/simple-description-of-popular-software-licenses/&quot;&gt;Simple description of popular software licenses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/wadefelix/article/details/6384317&quot;&gt;如何选择开源许可证？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 08 Nov 2014 01:40:00 +0800</pubDate>
        <link>http://www.waylau.com/simple-description-of-popular-software-licenses/</link>
        <guid isPermaLink="true">http://www.waylau.com/simple-description-of-popular-software-licenses/</guid>
        
        <category>opensource</category>
        
      </item>
    
  </channel>
</rss>
