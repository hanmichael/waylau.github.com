<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <meta name="description" content="Way Lau's Personal Site | www.waylau.com">
  <meta name="author" content="Way Lau">
  <meta name="keywords" content="Way Lau's Personal Site | www.waylau.com, Way Lau's Blog, 技术改变世界！, Way Lau">
  <title>Way Lau's Personal Site | www.waylau.com</title>
  <link rel="canonical" href="http://www.waylau.com">
  <link rel="icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/res/css/public.css">
  <link rel="stylesheet" href="/res/css/light.css">
  <script src="/res/js/light.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?28cf5fa48a599e39c5cc760931de942f";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
</head>
<body>
  <div id="blog">
    <div class="sidebar">
  <div class="profilepic">
    <a href="/"><img src="/res/img/icon.png" alt="logo"></img></a>
  </div>
  <h1 class="title"><a href="/">Way Lau's Blog</a></h1>
  <h2 class="sub-title">技术改变世界！</h2>
  <nav id="nav">
    <ul>
    
      <li><a href="/timing/"><i class="fa fa-clock-o"></i>&nbsp;时光机</a></li>
    
      <li><a href="/categories/"><i class="fa fa-tags"></i>&nbsp;分类</a></li>
    
      <li><a href="/tags/"><i class="fa fa-bookmark"></i>&nbsp;标签</a></li>
    
      <li><a href="http://labs.waylau.com/"><i class="fa fa-building"></i>&nbsp;示例</a></li>
    
      <li><a href="/books/"><i class="fa fa-book"></i>&nbsp;书籍</a></li>
    
      <li><a href="/about/"><i class="fa fa-paper-plane-o"></i>&nbsp;关于</a></li>
    
    </ul>
  </nav>  
  <nav id="sub-nav">
    <a class="weibo " href="http://weibo.com/waylau521" title="新浪微博" target="_blank"><i class="fa fa-weibo "></i></a>
    <a class="github" href="https://github.com/waylau" title="GitHub" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    <a class="twitter" href="https://twitter.com/waylau521" title="Twitter" target="_blank"><i class="fa fa-twitter fa-2x"></i></a>
    <a class="rss" href="/page/feed.xml" title="RSS订阅" target="_blank"><i class="fa fa-rss"></i></a>
  </nav>
  <div id="license">
    <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" title="本站所有作品采用：&#10;知识共享《署名 非商业性使用 相同方式共享 3.0》&#10;进行许可" >
    <img alt="License" height="31" width="88" src="/res/img/license.png" /></a>
  </div>
</div>
    <div class="main">
    
<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/requirement-analyse/">可行性分析与需求分析</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2013年02月27日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#management">management</a>
      </p>
    </header>
    <div class="post-main">
      <p>一、概念</p>

<p>可行性分析——可干否
需求分析——要干啥（避免需求蔓延）
二、可行性分析</p>

<p>柳传志“三不干”：没钱赚的事我们不干；有钱赚但投不起钱的事不干；有钱赚也投得起钱但没有可靠的人选，这样的事也不干。
可行性分析要素：经济、技术、社会环境、人
（1） 经济：成本——收益分析、短期——长远利益分析</p>

<p>（2） 技术：技术熟悉度、成熟度、可靠性、稳定性、技术成本、学习曲线</p>

<p>（3） 社会环境：市场、法律、道德</p>

<p>（4） 人——“人物，人才，人手，人渣。”最好的分工是让“人物”当领导，“人才”做第一线的开发人员，“人手”做行政人员，“人渣”负责行贿。</p>

<p>可行性分析报告（附录1）
三、需求分析</p>

<p>难点：客户说不清、需求老变更、理解有偏差
过程：
3.方式：</p>

<p>（1） 研究用户</p>

<p>（2） 调查问卷</p>

<p>（3） 原型完善</p>

<p>（4） 用户陈述</p>

<p>4.需求规格说明书（附录2）</p>

<p>附录1（可行性分析报告）</p>

<p>1．引言</p>

<p>1.1 编写目的</p>

<p>阐明编写可行性研究报告的目的，描述报告基本组成要素，指出读者对象。</p>

<p>1.2 项目背景</p>

<p>列出拟开发软件系统的名称，项目委托者、开发者和预期用户，说明该软件系统与其他系</p>

<p>统之间的关系等。</p>

<p>1.3 定义</p>

<p>列出报告中所使用的专门术语的定义和缩写词的原意。</p>

<p>1.4 参考资料</p>

<p>列出本文档需要引用的参考资料的来源。包括：已被批准的项目任务书、合同或上级机关</p>

<p>批文，与项目有关的已经公开发表的论文、著作，需要采用的标准或规范。</p>

<p>2．可行性研究的前提</p>

<p>2.1 基本要求</p>

<p>列出项目的各项基本要求，涉及功能、性能、数据输入、数据输出、数据处理流程、安全</p>

<p>保密要求、与其他系统的关系、完成期限等。</p>

<p>2.2 基本目标</p>

<p>涉及人力与设备费用的减少，工作环境的改善，工作效率的提高，处理速度、控制精度或</p>

<p>生产能力的提高，信息管理服务的改进，自动决策功能的改进等。</p>

<p>2.3 条件、假定和限制</p>

<p>涉及拟开发系统运行寿命的最小值，项目经费来源与限制，政策和法规方面的限制，硬件、</p>

<p>软件、开发环境和运行环境方面的条件与限制，可以利用的相关资源，拟开发系统要求投入使</p>

<p>用的最迟时间等。</p>

<p>3．对现有系统的分析</p>

<p>3.1 系统模型</p>

<p>可使用系统方框图、系统流程图说明现有系统的基本构造与基本处理流程。</p>

<p>3.2 工作负荷</p>

<p>列出现有系统所承担的工作与工作量。</p>

<p>3.3 费用支出</p>

<p>涉及现有系统运行过程中的人力、设备、空间、支持性服务和材料等各项支出。</p>

<p>3.4 局限性</p>

<p>指出现有系统存在的问题，并说明开发新系统或改造现有系统的必要性。</p>

<p>B.2 项目计划说明书209</p>

<p>4．对拟开发系统的分析</p>

<p>4.1 拟开发系统的体系结构</p>

<p>可使用系统方框图对拟开发系统的体系结构进行概要描述。</p>

<p>4.2 拟开发系统的工作模型</p>

<p>可使用系统流程图说明拟开发系统的基本处理流程。</p>

<p>4.3 拟开发系统的优越性</p>

<p>将拟开发系统与现有系统进行对比，并在诸如提高处理能力、减轻工作负荷、增强系统灵</p>

<p>活性和保证数据安全等方面，说明拟开发系统所具有的优越性。</p>

<p>4.4 拟开发系统可能带来的影响</p>

<p>涉及拟开发系统将对硬件设备、软件配置和用户操作等方面带来的影响。</p>

<p>5．对拟开发系统的可行性评价</p>

<p>5.1 技术可行性评价</p>

<p>说明拟开发系统在技术方面具备的可行性，例如，在当前技术允许的条件下，该系统的功</p>

<p>能目标能否达到；在规定的时间期限内，该系统的开发能否按期完工。</p>

<p>5.2 经济可行性评价</p>

<p>说明拟开发系统所需的开发费用和可以预期的经济收益，并由此进行成本效益分析。</p>

<p>5.3 社会因素的可行性评价</p>

<p>从法律法规、用户操作规程等方面进行可行性评价，例如项目合同中责任是否明确，拟开</p>

<p>发系统是否存在著作侵权，是否侵犯了国家、集体或他人的利益，拟开发系统是否充分考虑到</p>

      <div class="readall"><a href="/requirement-analyse/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/cairngorm-framework-project-development-process/">Cairngorm框架项目开发流程</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2013年02月26日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#cairngormflex">cairngormflex</a>
      </p>
    </header>
    <div class="post-main">
      <h2>Cairngorm框架的流程，由前往后 ，如下：</h2>

<h3>Services.mxml</h3>

<h3>VO</h3>

<h3>model</h3>

<h3>注册model</h3>

<h3>event // 常量值简短，有利于编译效率</h3>

<h3>DL</h3>

<h3>command</h3>

<h3>AppControl</h3>

<h3>view</h3>

      <div class="readall"><a href="/cairngorm-framework-project-development-process/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/software-engineering-overview/">软件工程概述</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2013年02月20日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#management">management</a>
      </p>
    </header>
    <div class="post-main">
      <p>一、软件工程概述</p>

<p>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</p>

<p>最主要的目的是为了解决软件危机。</p>

<p>&nbsp;</p>

<p>二、软件危机</p>

<p>表现：</p>

<p>1．软件开发成本、进度的估计很不准确</p>

<p>软件开发机构制定的项目计划跟实际情况有很大差距，使得开发经费一再突破。由于对工</p>

<p>作量和开发难度估计不足，进度计划无法按时完成，开发时间一再拖延，这种现象严重降低了软件开发机构的信誉。</p>

<p>2．软件产品常常与用户的要求不一致</p>

<p>在开发过程中，软件开发人员和用户之间缺乏信息交流。开发人员常常是在对用户要求只</p>

<p>有模糊了解的情况下就仓促上阵，匆忙着手编写程序。由于这些问题的存在，导致开发出来的软件不能满足用户的实际应用需要。</p>

<p>3．软件产品质量可靠性差</p>

<p>软件开发过程中，没有建立起确实有效的质量保证体系。一些软件项目为了赶进度或降低</p>

<p>软件开发成本，甚至不惜降低软件质量标准、偷工减料。</p>

<p>4．软件文档不完整、不一致</p>

<p>计算机软件不仅仅是程序，在软件开发过程中还应该产生出一系列的文档资料。实际上，</p>

<p>软件开发非常依赖这些文档资料。在软件开发过程中，软件开发机构的管理人员需要使用这些文档资料来管理软件项目；技术人员则需要利用文档资料进行信息交流；用户也需要通过这些文档资料来认识软件，对软件进行验收，熟悉软件的安装、操作等。但是，由于软件项目管理工作的欠缺，软件文档往往不完整，对软件的描述经常不一致，很难通过文档去跟踪软件开发过程中软件产品规格的变更。</p>

<p>5．软件产品可维护性差</p>

<p>软件中的错误非常难改正，软件很难适应新的硬件环境，很难根据用户的需要在原有软件</p>

<p>中增加一些新的功能。这样的软件是不便于重用的，以前开发的软件，一旦过时就不得不完全丢弃。</p>

<p>6．软件生产率低</p>

<p>软件生产率跟不上硬件的发展速度，不能适应计算机应用的迅速普及，以致现代计算机硬</p>

<p>件提供的巨大潜力不能被充分利用。</p>

<p>&nbsp;</p>

<p>三、危机产生的原因</p>

<p>看点历史：</p>

<p>观察软件的发展，可以发现软件生产有三个发展时代，即程序设计时代、程序系统时代和</p>

<p>软件工程时代。</p>

<p>1．程序设计时代（20 世纪50 年代）</p>

<p>这个时期的程序大多是自用，程序的编写者往往也就是使用者，软件还没有形成为产品。</p>

<p>由于早期程序大多是为某个具体应用而专门编写的，程序任务单一，因此，对程序的设计也就仅仅体现在单个程序的算法上。早期程序还往往只能在某台专门的计算机上工作，很难将程序由一台设备移植到另一台设备。</p>

<p>&nbsp;</p>

<p>2．程序系统时代（20 世纪60 年代）</p>

<p>这个时期的软件开发更多地依赖于个人创作。由于软件开发的主要内容仍然是程序编写，</p>

<p>软件开发的核心问题仍是技术问题；于是，用户的意图被忽视了，除了程序之外的其他文档、</p>

<p>技术标准、软件在今后运行过程中的维护等问题，也往往被忽视了。</p>

<p>软件已经开始成为产品，但软件的生产方式则是跟产品并不适宜的作坊创作方式。于是，</p>

<p>随着软件规模的不断扩大，软件危机现象在这个时期最终爆发出来。</p>

<p>&nbsp;</p>

<p>3．软件工程时代（20 世纪70 年代起）</p>

<p>1968 年在联邦德国召开的计算机国际会议上，专门针对软件危机问题进行了讨论，在这次</p>

<p>会议上正式提出并使用了“软件工程”术语。于是，软件工程作为一门新兴的工程学科诞生了。</p>

<p>在软件开发上，自20 世纪70 年代以来的30 年里，结构化的工程方法获得了广泛应用，</p>

<p>并已成为了一种成熟的软件工程方法学；而自20 世纪90 年代起，基于面向对象的工程方法，也已被应用于软件开发之中。应该说，采用工程的原理、技术和方法实施软件产品开发，以适应软件产业化发展的需要，成为了这个时期诸多软件企业的追求目标。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>真正的原因：</p>

<p>1．软件的不可见特性</p>

<p>软件不同于硬件，它是计算机系统中的逻辑部件，缺乏“可见性”。硬件错误往往可以通</p>

<p>过它的物理现象直接反映出来，例如，出现不正常的发热、噪音现象等；但软件错误没有这些直观表现，例如，软件中存在的程序行错误，就必须等到这行程序执行时才有可能被发现。因此，软件错误比起硬件错误来更难发现。软件的不可见特性也使得对软件项目的量化管理更难实施，对软件质量的量化评价更难操作。</p>

<p>2．软件系统规模庞大</p>

<p>软件成为产品以后已不同于早期程序，随着它的功能的增多，其规模、复杂程度越来越大。</p>

<p>例如，1968 年美国航空公司订票系统达到30 万条指令；IBM360OS 第16 版达到100 万条指令；1973 年美国阿波罗计划达到1 000 万条指令。这些庞大规模的软件系统，其复杂程度已超过了人所能接受的程度；但是，面对不断复杂的软件系统，其开发手段却仍然需要依靠开发人员的个人创造与手工操作。</p>

<p>3．软件生产工程化管理程度低</p>

<p>软件生产的工程化管理是软件作为产品所必须的，这意味着软件也需要像硬件一样，在软</p>

<p>件分析、设计完成之后，才能考虑软件的实现。应该说，工程化管理能够降低解决问题的代价。但是，许多软件的开发则往往是在分析、设计没有完成的情况下，就已经进入编码实现阶段。由于前期准备工作不充分，致使软件项目管理纷乱，严重影响软件项目成本、开发进度。</p>

<p>4．对用户需求关心程度不够</p>

<p>软件开发机构不熟悉用户业务领域。软件技术人员所关注的仅仅是计算机技术，它们不太</p>

<p>愿意和用户沟通，轻视对用户的需求调查，也缺乏有效的用户调查策略、手段。由于这些问题的存在，使得用户的需求意愿不能充分反映，或被错误理解。</p>

<p>实际上，软件是为用户开发的，只有用户才能真正了解他们自己的需要。由于没有对用户</p>

<p>做大量深入细致的调查研究，以致软件需求规格定义不准确，并最终使得完成后的软件不能适应用户的应用需要。</p>

<p>5．对软件维护重视程度不够</p>

<p>软件开发缺乏统一的规范。在软件产品开发过程中，开发者很少考虑到这个软件今后还需</p>

<p>要提供维护。但是，软件的使用周期漫长，软件错误具有隐蔽性，许多年之后软件仍可能需要改错。另外，软件的工作环境也可能会在几年后发生改变；用户也可能在软件运行几年以后，要求对它增加新的功能。这些都是属于软件维护问题。实际上，软件的可维护性是衡量软件质量的一项重要指标，软件可维护性程度高，软件就便于修正、改版和升级，由此可以使软件具有更长的使用寿命。</p>

<p>6．软件开发工具自动化程度低</p>

<p>尽管软件开发工具比30 年前已经有了很大的进步，但直到今天，软件开发仍然离不开工</p>

<p>程人员的个人创造与手工操作，软件生产仍不可能像硬件设备的生产那样，达到高度的自</p>

<p>动化。</p>

<p>&nbsp;</p>

<p>四、探讨如何解决危机</p>

<ol>
<li>软件工程的主要环节有：人员管理、项目管理、可行性与需求分析、系统设计、程序设计、测试、维护</li>
</ol>


<p>&nbsp;</p>

<p>&nbsp;</p>

<ol>
<li>常见的软件工程模型有：线性模型（瀑布模型），渐增式模型，螺旋模型，快速原型模型，增量模型，喷泉模型等</li>
</ol>


<p>最早出现的软件工程模型是线性模型（又称瀑布模型）。</p>

<p>瀑布模型核心思想是按工序将问题化简，将功能的实现与设计分开，便于分工协作，即采用瀑布模型用结构化的分析与设计方法将逻辑实现与物理实现分开。将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。</p>

<p><a href="http://www.waylau.com/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e6%a6%82%e8%bf%b0/attachment/002/" rel="attachment wp-att-199"><img alt="002" src="http://www.waylau.com/wp-content/uploads/2013/02/002-300x182.jpg" width="300" height="182" /></a></p>

<p>优点</p>

<p>1）为项目提供了按阶段划分的检查点。</p>

<p>2）当前一阶段完成后，您只需要去关注后续阶段。</p>

<p>缺点</p>

<p>1）在项目各个阶段之间极少有反馈。</p>

<p>2）只有在项目生命周期的后期才能看到结果。</p>

<p>3）通过过多的强制完成日期和里程碑来跟踪各个项目阶段。</p>

<p>4)瀑布模型的突出缺点是不适应用户需求的变化.</p>

<p>&nbsp;</p>

<p>线性模型太理想化，太单纯，已不再适合现代的软件开发模式，几乎被业界抛弃。但是复杂的“非线性”问题时，总是千方百计地将其分解或转化为一系列简单的线性问题。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>螺旋模型：</p>

<p>基本做法是在“瀑布模型”的每一个开发阶段前引入一个非常严格的风险识别、风险分析和风险控制，它把软件项目分解成一个个小项目。每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。</p>

<p><a href="http://www.waylau.com/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e6%a6%82%e8%bf%b0/attachment/003/" rel="attachment wp-att-200"><img alt="003" src="http://www.waylau.com/wp-content/uploads/2013/02/003-300x251.jpg" width="300" height="251" /></a></p>

<p>优点</p>

<p>1）设计上的灵活性,可以在项目的各个阶段进行变更。</p>

<p>2）以小的分段来构建大型系统,使成本计算变得简单容易。</p>

<p>3）客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。</p>

<p>4）随着项目推进,客户始终掌握项目的最新信息 , 从而他或她能够和管理层有效地交互。</p>

<p>5）客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品。</p>

<p>缺点</p>

<p>很难让用户确信这种演化方法的结果是可以控制的。建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。</p>

<p>螺旋模型的项目适用：</p>

<p>对于新近开发，需求不明确的情况下，适合用螺旋模型进行开发，便于风险控制和需求变更！</p>

<p>&nbsp;</p>

<p>快速原型模型</p>

      <div class="readall"><a href="/software-engineering-overview/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/linux-ubuntu-golang-under-environment-variables/">Linux(Ubuntu)下设置golang环境变量</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2013年01月31日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#golang">golang</a>
      </p>
    </header>
    <div class="post-main">
      <p>1).源代码安装go语言</p>

<p>Go的工具链采用C语言编写，要构建它，你需要安装一个C编译器，本例采用gcc工具; 进入linux 终端，输入命令行</p>

<blockquote><p>sudo apt-get install build-essential</p></blockquote>

<p>Go使用Mercurial进行版本管理，首先你必须安装了Mercurial,对于 Ubuntu/Debian 系统先安装easy_install;</p>

<blockquote><p>sudo apt-get install mercurial</p></blockquote>

<p>出现Processing triggers for python-support...需先安装python环境 执行</p>

<blockquote><p>sudo apt-get install python-setuptools python-dev</p>

<p>sudo easy_install mercurial</p></blockquote>

<p>如果 还不行，那直接下载Mercurial安装</p>

<p>获取GO代码</p>

<blockquote><p>hg clone -r release https://go.googlecode.com/hg/ $GOROOT</p></blockquote>

<p>安装Go:</p>

<blockquote><p>cd $GOROOT/src</p>

<p>./all.bash</p></blockquote>

<p>如果 还不行，那直接下载编译好的代码安装 解压 go包放用户根目录下</p>

<blockquote><p>sudo tar zxvf ~/Downloads/go1.0.3.linux-386.tar.gz -C /opt</p></blockquote>

<p>2).设置环境变量,在/etc/profile文件同添加以下内容</p>

<pre><code>sudo gedit /etc/profile

export GOROOT=$HOME/go
export GOBIN=$GOROOT/bin
export GOARCH=386
export GOOS=linux
export GOPATH=$HOME/workspacego
export PATH=.:$PATH:$GOBIN
</code></pre>

<p>GOARCH、GOOS为可选配置，交叉编译时有用 GOPATH设置工作空间,允许多个目录，当有多个目录时，用分隔符分隔，当有多个GOPATH时，默认会将go get的内容放在第一个目录下;</p>

<p>$GOPATH 目录约定有三个子目录：</p>

<p>src 存放源代码（比如：.go .c .h .s等）</p>

<p>pkg 编译后生成的文件（比如：.a）</p>

<p>bin 编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中）</p>

<p>应用刚刚配置的环境变量:source /etc/profile</p>

<p>上面的配置是针对系统级别的，建议采用用户级别的配置如下：</p>

<p>如果用户根目录下不存在.bash_profile，则</p>

<pre><code>cat &gt; .bash_profile

export GOROOT=$HOME/go
export PATH=$PATH:$GOROOT/bin
export GOPATH=$HOME/workspacego
</code></pre>

<p>CTRL_D(这是按 CTRL - D两个键同时)</p>

<p>每次启动系统应用</p>

<blockquote><p>. ./.bash_profile</p></blockquote>

<p>官方建议把配置记录在用户在～/.bashrc或者 ～/.profile中，这样 登陆就可以使用go 而不用，每次登陆系统都要执行. ./.bash_profile</p>

<p>配置文件的区别，请参阅后面的附录</p>

<p>3).查看go是否是release版</p>

<blockquote><p>hg identify</p></blockquote>

<p>更新go到新版本</p>

<pre><code>cd $GOROOT

hg pull

hg update release

./all.bash
</code></pre>

<p>4).浏览本地doc</p>

<p>在命令行执行</p>

<blockquote><p>godoc -http=:8080</p></blockquote>

<p>在浏览器地址输入：<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>，即可进入doc界面</p>

<p>5).搭建基于浏览器的交互式Go编程指南-gotour</p>

<p>5.1).安装Go语言英文教程：</p>

<blockquote><p>sudo go get code.google.com/p/go-tour/gotour</p></blockquote>

<p>5.2).安装Go语言中文教程：</p>

<blockquote><p>sudo go get bitbucket.org/mikespook/go-tour-zh/gotour</p></blockquote>

<p>在命令行执行gotour，在浏览器地址输入：http://127.0.0.1:3999，即可进入教程的学习界面。</p>

<p>附录</p>

<p>参考：<a href="http://blog.csdn.net/wumingxing0228/article/details/6050175">http://blog.csdn.net/wumingxing0228/article/details/6050175</a></p>

<p>环境变量是和Shell紧密相关的，用户登录系统后就启动了一个Shell。对于Linux来说一般是bash，但也可以重新设定或切换到其它的 Shell。对于UNIX，可能是CShelll。环境变量是通过Shell命令来设置的，设置好的环境变量又可以被所有当前用户所运行的程序所使用。对于bash这个Shell程序来说，可以通过变量名来访问相应的环境变量，通过export来设置环境变量。下面通过几个实例来说明。</p>

<p>1)etc/profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置. 注：在这里我们设定是为所有用户可使用的全局变量。</p>

<p>2)/etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>

<p>3)~/.bashprofile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. 注：~在LINUX下面是代表HOME这个变量的。 另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是~/.bashprofile； ~/.bash_login或 ~/.profile其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bashprofile、 ~/.bashlogin、 ~/.profile。比如我用的是Ubuntu，我的用户文件夹下默认的就只有~/.profile文件。</p>

<p>4)~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取. (注：这个文件是 .开头的，所以在文件夹中被隐藏了) 那么我们如何添加自己定义的环境变量呢？ 用记事本打开这个文件，然后在里面最后写上: xiaokang=kangkang 然后保存，这样每次打开一个新的terminal的时候，我们这个变量就生效了。记住，如果你已经打开一个terminal，然后你修改了这个文件，那么在这个terminal下是不会生效的。一般情况用户最好在这里进行修改，但是有时候会覆盖父级的变量，比如PATH是ROOT设定的，但是如果你在这个文件里面写了PATH=xx,那么将来所有的PATH都成了xx了，所以我们应该在这个文件中写为： PATH＝$PATH:xx 这样就把原来的和你自己的一起加上了。而且注意在LINUX系统下用：分割表示并列，而不是windo的； 3和4都是在用户目录下的，他们唯一的不同是: .bash_profile只能在登录的时候启动一次。在我的Ubuntu里面这个3文件似乎没有。</p>

<p>5)~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是/"父子/"关系.</p>

<p>~/.bash_profile 是交互式、login 方式进入 bash 运行的 ~/.bashrc 是交互式 non-login 方式进入 bash 运行的 通常二者设置大致相同，所以通常前者会调用后者。</p>

<p>好的，总结一下他们的执行方式： 当你登录并且登录shell是bash时,bash首先执行/etc/profile文件中的命令(如果该文件存在),然后它顺序寻找~ /.bashprofile,~/.bashlogin或~/.profile文件,并执行找到的第一个可读文件中的命令.当登录bash退出时,它 将执行~/.bashlogout文件中的命令. 当启动一个交互的bash时,它将执行~/.bashrc文件中的命令(如果该文件存在并且可读).当非交互地启动以运行一个shell脚本时,bash将查找bashenv环境变量,确定执行文件的名称.</p>

      <div class="readall"><a href="/linux-ubuntu-golang-under-environment-variables/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/share-how-to-upload-code-github-project/">如何在github上传代码、分享项目</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2013年01月13日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#git">git</a>
      </p>
    </header>
    <div class="post-main">
      <h4>首先当然是要创建github账户，登录<a href="https://github.com">https://github.com</a>有邮箱即可，略</h4>

<h4>而后需要在本地安装Git软件，地址：<a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a>（Git可以理解为svn等类型的代码管理软件），略</h4>

<h4>新建一个 repository（仓库）</h4>

<p>填写Repository name 、Description，选择Initialize this repository with a README
<img src="http://a.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=bb59dda8fadcd100c99cf82442b0362d/9e3df8dcd100baa14d8f301e4510b912c9fc2ef7.jpg?referer=c2399ba6ca95d1438361d0138aad&x=.jpg"/></p>

<p>此时一个repository创建完成 ，自动生成README.md和.gitgnore文件。
<img src="http://f.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=87a6b046552c11dfdad1bf26531c13ed/f3d3572c11dfa9ec6f6c21b260d0f703908fc1d1.jpg?referer=b4709b6cd52a60590b07d52a2fcf&x=.jpg"/></p>

<h4>获取项目</h4>

<p>先拷贝仓库地址
<img src="http://d.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=0866a951b54543a9f11bfac92e2cfbbf/eac4b74543a9822674835c828882b9014b90ebd1.jpg?referer=c08b484460d9f2d3790610df55cf&x=.jpg"/></p>

<p>点击“Fork”
<img src="http://g.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=4d628b7f17ce36d3a60483350ac84bba/c8ea15ce36d3d539a0d778663887e950342ab0a8.jpg?referer=aed9397956e736d10104b838f066&x=.jpg"/></p>

<p>在切换到工作区间，本例子为D:\workspaceGit</p>

<p>用git命令将项目拷贝到工作区间，地址为上面的仓库地址 <code>git clone https://github.com/waylau/go_for_java_programmers.git</code>
<img src="http://c.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=e6b11ef536a85edffe8cfe26796f781e/5d6034a85edf8db191930bc10b23dd54574e74d1.jpg?referer=a25c9395b8a1cd115ca14610b4cf&x=.jpg"/>
此时本地工作区间便已经存在该项目
<img src="http://b.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=34b296bf2a34349b70066e80f9d164f3/d52a2834349b033b4a2a8b7f17ce36d3d439bdf0.jpg?referer=6d46cf8503e939010f15b90efbae&x=.jpg"/>
打开README.md里面即为项目描述</p>

<h4>上传更新</h4>

<p>添加项目代码或者文件到该项目下
<img src="http://b.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=a81fe513cb177f3e1434fc0840f44afa/a686c9177f3e6709b0ea325a39c79f3df9dc55a8.jpg?referer=add0776fe4cd7b89b07b0eb39366&x=.jpg"/></p>

<p>用git添加要上传的代码文件, <code>add .</code> 表示添加所有</p>

<blockquote><p>git add</p></blockquote>

<p>添加评论或说明</p>

<blockquote><p>git commit –m ‘新增项目’</p></blockquote>

<p>用git命令连接远程的项目</p>

<blockquote><p>git remote add upstream https://github.com/waylau/go_for_java_programmers.git</p></blockquote>

<p>获取在本地没有修改过的文件中修改过的代码</p>

<blockquote><p>git fetch upstream</p></blockquote>

<p>提交代码。身份验证，填入github的用户名和密码</p>

<blockquote><p>git push origin master</p></blockquote>

<p><img src="http://f.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=a59f78bc2ff5e0feea1889046c5b4595/3b292df5e0fe9925e9b11ef536a85edf8cb171d1.jpg?referer=32898ba872cf3bc7b117f9dcbfcf&x=.jpg"/></p>

      <div class="readall"><a href="/share-how-to-upload-code-github-project/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/go-for-java-programmers-java-developer-oriented-go-programming/">Go For Java Programmers(面向Java开发者的GO编程)</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2013年01月13日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#golangjava">golangjava</a>
      </p>
    </header>
    <div class="post-main">
      <p>本文旨在帮助JAVA开发者迅速掌握 Go语言.</p>

<p>开始用一个很容易能被所有的Java程序员认出的例子来突出特色，然后对GO的框架给出了详细的的描述，最后用一个例子来说明GO结构中没有与 Java直接对应处。</p>

<h2>Hello stack (一个栈的例子)</h2>

<p>为了吊起你的胃口，我们用一个麻雀虽小，五脏俱全和符合习惯的例子对应这个<a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/src/collection/Stack.java">Stack.java</a> 程序</p>

<pre><code class="java">
// 包collection实现了生成栈.
package collection

// 零值栈是一个空栈，准备被使用.
type Stack struct {
    data []interface{}
}

// Push函数将x添加到栈顶.
func (s *Stack) Push(x interface{}) {
    s.data = append(s.data, x)
}

// Pop函数是将栈顶元素移除并返回.
// 在Pop函数执行在空栈时，会被一个运行时的error警示.
func (s *Stack) Pop() interface{} {
    i := len(s.data) - 1
    res := s.data[i]
    s.data[i] = nil  // 避免内存泄露
    s.data = s.data[:i]
    return res
}

// Size函数返回栈中元素的个数
func (s *Stack) Size() int {
    return len(s.data)
}
</code></pre>

<p><a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/src/collection/stack.go">stack.go</a></p>

<ul>
<li>顶级声明出现之前，直接的评论是文档注释。他们是纯文字。.</li>
<li>对于声明，你把名字写在类型后面.</li>
<li><code>struct</code> 对应Java中的类, 但struct组成不是方法而只能是变量.</li>
<li><code>Tinterface{}</code>类型对应Java的 <code>Object</code>. 在GO中它被所有的类型所实现，而不仅仅是引用类型.</li>
<li>代码段 <code>(s *Stack)</code> 声明了一个方法，接收者 <code>s</code> 对应Java中的 <code>this</code>.</li>
<li>操作符<code>:=</code>声明并初始化了一个变量. 它的类型可以从初始化表达式中推导出.</li>
</ul>


<p>这里是一个的Hello world程序，演示了如何使用<code>collection.Stack</code>的抽象数据类型.</p>

<pre><code class="go">
package collection_test

import (
    collection "."
    "fmt"
)

func Example() {
    var s collection.Stack
    s.Push("world")
    s.Push("hello, ")
    for s.Size() &gt; 0 {
        fmt.Print(s.Pop())
    }
    fmt.Println()
    //输出: hello, world
}
</code></pre>

<p><a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/src/collection/example_test.go">example_test.go</a></p>

<h2>概念上的差异</h2>

<ul>
<li>Go的构造器没有类。Go 用 structs 和 interfaces来替代实例化方法，类的继承机制，动态方法查找.也可用于Java使用泛型接口</li>
<li>Go提供所有类型的指针的值，而不只是对象和数组。对于任何类型 T，有一个相应的指针类型*T表示指针指向类型 T的值。 offers pointers to values of all types, not just objects and arrays.</li>
<li>Go允许任何类型都有方法而没有装箱的限制 allows methods on any type; no boxing is required. 方法receiver,在Java中对应this可以是直接值或者是指针.</li>
<li>数组在Go就是值. 当一个数组被当做函数的参数时，这个函数接收到的是数组的拷贝而不是它的指针. 然而在实践中,函数经常使用 slices作为参数; slices引用了基础数组.</li>
<li>该语言提供了字符串，一个字符串行为就像一个字节片，但是是不可改变的。</li>
<li>该语言中的哈希表被称作maps.</li>
<li>该语言提供了独立运行的线程goroutines 和他们之间的通信渠道channels.</li>
<li>某些类型(maps, slices, 和 channels)是按引用传递，而不是值。也就是说，传递一个map到函数并而不是拷贝map，如果函数修改了map，将被调用者看到变化。在Java术语来说，可以认为这是一个map的引用.</li>
<li>Go提供了两种访问级别对应Java的public和包的private.如果它的命名是大写字母开头就是最高级别public，反之就是包的private.</li>
<li>作为替换Java中的异常机制, Go采用了类型 error值来表示事件，如文件结尾,和运行时的panics来表示运行时的错误，如数组越界等.</li>
<li>Go不支持隐式类型转换。混合使用不同类型的操作需要显式转换.</li>
<li>Go不支持函数重载。在同一范围内的函数和方法必须具有唯一的名称.</li>
<li>Go使用nil表示无效的指针，类似于Java使用null.</li>
</ul>


<h2>句法</h2>

<h3>声明</h3>

<p>声明是跟Java是相反的。你在类型后面再写名称，类型声明从左往右更容易读</p>

<p>Go  与Java相对应的</p>

<table>
<tbody>
<tr>
<th>Go</th>
<th>与Java相对应的</th>
</tr>
<tr>
<td><code>var v1 int</code></td>
<td><code>int v1;</code></td>
</tr>
<tr>
<td><code>var v2 *int</code></td>
<td><code>Integer v2;</code></td>
</tr>
<tr>
<td><code>var v3 string</code></td>
<td><code>String v3 = "";</code></td>
</tr>
<tr>
<td><code>var v4 [10]int</code></td>
<td><code>int[] v4 = new int[10]; // v4 在Go中是一个值.</code></td>
</tr>
<tr>
<td><code>var v5 []int</code></td>
<td><code>int[] v5;</code></td>
</tr>
<tr>
<td><code>var v6 *struct { a int } </code></td>
<td><code>C v6; // Given: class C { int a; }</code></td>
</tr>
<tr>
<td><code>var v7 map[string]int</code></td>
<td><code>HashMap&lt;String,Integer&gt; v7;</code></td>
</tr>
<tr>
<td><code>var v8 func(a int) int</code></td>
<td><code>F v8; // Given: interface F { int f(int a); }</code></td>
</tr>
</tbody>
</table>


<p>声明的一般形式是一个关键字后面跟着被声明对象的名字.这个关键字是const, type, var, 或者func. 您也可以使用一个关键字，后面的括号中跟着一系列声明.</p>

<pre><code>var (
    n int
    x float64
)
</code></pre>

<p>当声明一个函数，你必须提供每个参数的名称，或者不提供任何参数的名称，你不能提供了一些而忽略了另外一些名字。您可以组合几个相同类型的名称:</p>

<pre><code>func f(i, j, k int, s, t string)
</code></pre>

<p>一个变量可以在声明时初始化。当这样做时，指定的变量的类型是允许的，但不是必需的。当未指定类型，默认的是初始化表达式的类型.</p>

<pre><code>var v9 = *v2
</code></pre>

<p>如果一个变量没有立即初始化，必须要制定类型。那样的情况下，它它会被隐式初始化该类型的零值zero value(0, nil, "", 等.). Go不存在未初始化的变量.</p>

<h3>短声明</h3>

<p>在函数中，一个短的声明句法是 := 表示.</p>

<pre><code>v10 := v1
</code></pre>

<p>这等效于</p>

<pre><code>var v10 = v1
</code></pre>

<h3>函数类型</h3>

<p>在Go中，函数都是一等公民。Go的函数类型表示一组所有具有相同的参数和返回类型的函数.</p>

<pre><code>type binOp func(int, int) int

var op binOp
add := func(i, j int) int { return i + j }

op = add
n = op(100, 200)  // n = 100 + 200
</code></pre>

<h3>多重分配</h3>

<p>GO允许多重分配。在右边的表达式会在评估后，再分配到任何的左操作数。</p>

<pre><code>i, j = j, i  //交换i和j.
</code></pre>

<p>函数可以具有多个返回值，表示由括号中的列表。返回的值可以存储分配给一个变??量列表。</p>

<pre><code>func f() (i int, pj *int) { ... }
v1, v2 = f()
</code></pre>

<h3>空白标识符</h3>

<p>空白标识符提供了一种忽略多值表达式返回值的方式，用下划线字符表示： The blank identifier, represented by the underscore character, provides a way to ignore values returned by a multi-valued expression:</p>

<pre><code>v1, _ = f()  // 忽略f()返回的第二个值.
</code></pre>

<h3>分号和格式</h3>

<p>为了消除对分号和格式不必要的担忧，你可能会用gofmt程序来写GO风格的标准代码，虽然这种风格看起来很古怪，但熟悉了之后最终会像其他语言风格一样变得舒服</p>

<p>Go的代码在实际中很多出现分号。严格来说，Go所有的声明都用分号结束。但是Go毫无疑问会在每个非空白行的结尾插入一个分号，除非它还没有完. 这样做的后果是，在某些情况下，Go不允许断行。举例，你可能会像下面这样写：</p>

<pre><code>func g()
{            //无效的;“{”应该是在前面那一行。
}
</code></pre>

<p>在g()后面会被插入一个分号，这样就使他像是一个函数声明而不是函数定义了类似的，你不能这样写：</p>

<pre><code>if n == 0 {
}
else {       // 无效的; "else {" 应该是在前面那一行。
}
</code></pre>

<p>在} 后和else前面会插入一个分号,导致句法错误.</p>

<h3>条件语句</h3>

<p>Go在条件语句中并不使用括号，像 if条件语句 , for 条件语句的表达式, switch 条件语句的值. 另一方面，它并不需要在 if或 for条件语句中加花括号</p>

<pre><code>if a &lt; b { f() }
if (a &lt; b) { f() }           // 括号是不必要的.
if (a &lt; b) f()               // 无效的
for i = 0; i &lt; 10; i++ {}
for (i = 0; i &lt; 10; i++) {}  // 无效的
</code></pre>

<p>此外, if和switch 接收一个可选的初始化的状态，那么惯用做法是建一个局部变量</p>

<pre><code>if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</code></pre>

<h3>For 语句</h3>

<p>Go没有while和do-while语句. 当for语句的条件比较单一时，他的作用就像是while语句. 完全省略条件则产生一个死循环。</p>

<p>for语句可能包含range遍历 strings, arrays, slices, maps, 或 channels。除了写成下面这样</p>

<pre><code>for i := 0; i &lt; len(a); i++ { ... }
</code></pre>

<p>去遍历a的元素，也可以写成</p>

<pre><code>for i, v := range a { ... }
</code></pre>

<p>这里的i指索引， v代表的array, slice, 或者string的连续元素。对于字符串，i是一个字节的索引，v指向rune类型（rune类型是int32)的一个别名）。maps迭代产生键 - 值对，而channels只产生一个迭代值。</p>

<h3>Break和continue</h3>

<p>像Java一样，GO许可break和continue指定一个标签，但标签上必须指的for, switch, 或者 select 语句.</p>

<h3>Switch 语句</h3>

<p>在 switch 语句，case 标签默认情况下不通过，但你可以让他们 fallthrough语句结束的情况下通过了。</p>

<pre><code>switch n {
case 0:  // empty case body
case 1:
    f()  // f is not called when n == 0.
}
</code></pre>

<p>但是一个case可以包含过个值</p>

<pre><code>switch n {
case 0, 1:
    f()  // f is called if n == 0 || n == 1.
}
</code></pre>

<p>case的值可以支持任何类型的相等比较操作符，如字符串或指针。一个丢失表达式的switch语句 等价于表达式为 true。</p>

<pre><code>switch {
case n &lt; 0:
    f1()
case n == 0:
    f2()
default:
    f3()
}
</code></pre>

<h3>++ 和 -- 语句</h3>

<p>++和--只能作为后缀操作符，和仅在语句中，而不是在表达式中。例如，你不可以写n = i++。</p>

<h3>defer语句</h3>

<p>defer语句调用一个函数的执行被推迟到函数返回那一刻。defer语句执行时，被递延的函数的参数被计算，并保存，以备将来使用</p>

<pre><code>f, err := os.Open("filename")
defer f.Close()  // f will be closed when this function returns.
</code></pre>

<h2>Constants（常量）</h2>

<p>GO中的常数可能是untyped的。这适用于无类型的常量表达式的数字文本，和使用const声明的无类型的常量表达式。当它被用在需要一个带类型的值的背景下，一个无类型的常量的可以被转变成有类型的值。这样常量的使用相对自由，即使Go没有隐式类型转换</p>

<pre><code>var a uint
f(a + 1)    // The untyped numeric constant 1 becomes typed as uint.
f(a + 1e3)  // 1e3 is also typed as uint.
</code></pre>

<p>语言对非类型化的数字常量不限制大小。限制仅适用于使用一个常量时，其中一种类型是必需的。</p>

<pre><code>const huge = 1 &lt;&lt; 100
var n int = huge &gt;&gt; 98
</code></pre>

<p>如果是不存在的变量声明的类型和相应的表达式的计算结果为一个非类型化的数字常数，这个常数是被转换为 rune, int, float64, 或者complex128 类型，取决于该值是否一个字符，整数，浮点，或复杂的常数。</p>

<pre><code>c := '?'      // rune (alias for int32)
n := 1 + 2    // int
x := 2.7      // float64
z := 1 + 2i   // complex128
</code></pre>

<p>GO 不存在枚举类型。相反，你可以使用特殊的名字iota在单一的const声明中从而得到一系列累加值。当初始化表达式省略为一个 const，它重用了前面的表达式。</p>

<pre><code>const (
    red = iota  // red == 0
    blue        // blue == 1
    green       // green == 2
)
</code></pre>

<h2>Structs（结构体）</h2>

<p>结构体对应于Java中的类，但一个结构的成员不能是方法，而是变量。结构体的指针是类似Java的的引用变量。与Java类不同的是，结构也可以被定义为直接值。在这两种情况下使用 .来访问结构体的成员。</p>

<pre><code>type MyStruct struct {
    s string
    n int64
}

var x MyStruct      // x is initialized to MyStruct{"", 0}.
var px *MyStruct    // px is initialized to nil.
px = new(MyStruct)  // px points to the new struct MyStruct{"", 0}.

x.s = "Foo"
px.s = "Bar"
</code></pre>

<p>在Go中，方法可以与任何命名的类型关联，而不仅仅是与结构体。详情见方法和接口的讨论。</p>

<h2>Pointers（指针）</h2>

<p>如果你有一个int或struct或者array需要分配对象的内容复制。 想达到Java的引用变量的效果，Go使用指针。对于任何类型e T,有一个相应的指针类型*T，表示指针类型 T的值</p>

<p>给指针变量分配存储空间，使用内置函数new，传入一个类型，并返回一个指针，指向分配的存储空间。分配的空间将被零初始化的类型。例如， new(int) 分配存储为一个新的int，初始化它的值为e 0，并返回它的地址，类型 *int。</p>

<p>Java代码T p = new T()，其中 T是一个两个int型实例变量a和b的类，对应于</p>

<pre><code>type T struct { a, b int }
var p *T = new(T)
</code></pre>

<p>或者习惯性这样干</p>

<pre><code>p := new(T)
</code></pre>

<p>var v T代表声明，声明了一个变量包含一个值类型 T，这在Java中是没有的。也可使用复合方式创建并初始化值。</p>

<pre><code>v := T{1, 2}
</code></pre>

<p>等同于</p>

<pre><code>var v T
v.a = 1
v.b = 2
</code></pre>

<p>对于类型T的操作数x，地址运算符 &amp;x提供值类型为*T的x的地址，</p>

<h2>Slices（切片）</h2>

<p>slice是概念上一个结构包含三个域：一个数组的指针、长度和容量。切片支持[]操作符来访问底层数组的元素。内置的len函数返回的切片长度。内置的的cap函数返回切片的能力。</p>

<p>给定一个数组，或另一个切片，通过a[i:j]来创建一个新的切片。这个新创建的切片指向a，从索引i开始，并结束索引j之前。它的长度是j - i。如果i 被省略，切片从0开始。如果j 被省略，切片在 len(a)结束。新切片跟 a一样指向相同的数组。即，改变后组成的新的切片的元素在a都能见到。新切片的容量就是简单的a减去i。数组的容量就是数组的长度。</p>

<pre><code>var s []int
var a [10]int

s = a[:]  // short for s = a[0:len(a)]
</code></pre>

<p>如果你创建一个值类型为[100]byte（100个字节，也许是一个缓冲区的数组），你想不复制它，而将它传递给函数，那么函数的参数声明类型[]byte，并传入数组的切片。切片也可以用 make的函数创建（如下文所述）。</p>

<p>切片组合采用内置的append函数，Java的ArrayList提供相同的功能。</p>

<pre><code>s0 := []int{1, 2}
s1 := append(s0, 3)      // append a single element
s2 := append(s1, 4, 5)   // append multiple elements
s3 := append(s2, s0...)  // append a slice
</code></pre>

<p>切片语法，也可以使用在字符串上。它返回一个新字符串，其值是原始的字符串的子串</p>

<h2>make函数</h2>

<p>Map and channel values must be allocated using the built-in function make. For example, calling map和channel值必须使用内置的函数make。例如，调用</p>

<p>make(map[string]int)
map[string]int返回一个新分配的值类型。相对于new， make 返回的是实际的对象，而不是一个地址。这是一致的事实，map和channel是引用类型。</p>

<p>对于map，make函数将容量作为一个可选的第二个参数的提示。对于channel，有一个可选的第二个参数来设置channel的缓冲能力，默认为0（无缓冲）。</p>

<p>make函数也可以用来分配一个切片。在这种情况下，它分配内存给基本数组并返回一个引用他的切片。该切片中的元素数是一个必需的参数。第二个可选的参数是切片的容量。</p>

<pre><code>m := make([]int, 10, 20)  // Same as new([20]int)[:10]
</code></pre>

<h2>方法和接口</h2>

<h3>方法</h3>

<p>方法看起来像一个普通的函数定义，但它有一个receiver（接收者）。receiver是类似Java实例方法中的this引用。</p>

<pre><code>type MyType struct { i int }

func (p *MyType) Get() int {
    return p.i
}

var pm = new(MyType)
var n = pm.Get()
</code></pre>

<p>这声明了一个方法Get与MyType关联的。receiver被命名为p 在函数体内。</p>

<p>命名的类型来定义方法。如果您转换不同类型的值，新的值将有新的类型，而不是那些旧的类型。</p>

<p>你可以定义一个内置类型的方法，用新的命名类型声明。新的类型和内置的类型是不同的。</p>

<pre><code>type MyInt int

func (p MyInt) Get() int {
    return int(p)  // The conversion is required.
}

func f(i int) {}
var v MyInt

v = v * v          // The operators of the underlying type still apply.
f(int(v))          // int(v) has no defined methods.
f(v)               // INVALID
</code></pre>

<h3>接口</h3>

<p>Go接口类似于Java接口，但可被视为一个实现该接口提供任何类型的在Go接口命名的方法。明确的声明是不必要的。</p>

<p>接口像这样:</p>

<pre><code>type MyInterface interface {
    Get() int
    Set(i int)
}
</code></pre>

<p>自从 MyType 已经有了Get 方法, 我们可以让 MyType满足接口通过添加</p>

<pre><code>func (p *MyType) Set(i int) {
    p.i = i
}
</code></pre>

<p>现在任何只要将MyInterface当做参数就可以接收类型是*MyType的变量</p>

<pre><code>func GetAndSet(x MyInterface) {}

func f1() {
    var p MyType
    GetAndSet(&amp;p)
}
</code></pre>

<p>在Java术语，给MyType 定义 Set和Get 使MyType自动实现了MyInterface接口。这种类型型可满足多个接口。这是一种形式的鸭子类型。</p>

<blockquote><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”
James Whitcomb Riley</p></blockquote>

<h3>匿名域</h3>

<p>匿名域可以用于实现很像一个Java子类的东西。</p>

<pre><code>type MySubType struct {
    MyType
    j int
}

func (p *MySubType) Get() int {
    p.j++
    return p.MyType.Get()
}
MySubType有效实现的像是MyType的子类型.

func f2() {
    var p MySubType
    GetAndSet(&amp;p)
}
</code></pre>

<p>Set方法是继承自MyType的，因为关联了匿名域的方法的变为了封闭类型的方法。在这种情况下，因为 MySubType有一个匿名与域 MyType类型，所以为 MyTypee的方法也成为MySubType的方法。Get方法被重写，Set方法被继承。</p>

<p>这是与Java中的子类不完全相同。当一个匿名域的方法被调用时，它的 receiver就是这个匿名域，而不是周围的结构体。换句话说，匿名域上的方法的不会动态调度。当你想要实现相当于Java的动态方法查找，请使用接口。</p>

<pre><code>func f3() {
    var v MyInterface

    v = new(MyType)
    v.Get()  // Call the Get method for *MyType.

    v = new(MySubType)
    v.Get()  // Call the Get method for *MySubType.
}
</code></pre>

<h3>类型断言</h3>

<p>使用一个类型断言可以使具有一个接口类型的变量转换成具有不同的接口类型。这是在运行时动态执行。与Java不同，并不需要任何声明两个接口之间的关系。</p>

<pre><code>type Printer interface {
    Print()
}

func f4(x MyInterface) {
    x.(Printer).Print()  // type assertion to Printer
}
</code></pre>

<p>转换为Printer 完全是动态的。只要x（x中存储的值的实际类型）的 动态类型 定义了一个Print方法。</p>

<h2>Errors(错误机制)</h2>

<p>Go的多值的返回可以很容易地沿着正常的返回值返回详细的错误消息。按照惯例，这样的error类型的消息，就像下面的简单的内置接口</p>

<pre><code>type error interface {
    Error() string
}
</code></pre>

<p>例如，os.Open函数当它无法打开文件时返回一个非零error值。</p>

<pre><code>func Open(name string) (file *File, err error)
</code></pre>

<p>以下代码使用 os.Open打开一个文件。如果 error发生，它调用 log.Fatal打印错误信息并停止。</p>

<pre><code>f, err := os.Open("filename.ext")
if err != nil {
    log.Fatal(err)
}
// do something with the open *File f
</code></pre>

<p>error的接口只需要一个 Error的方法，但具体的error的实现往往有额外的方法，允许调用者进行检查错误的详细信息</p>

<h2>Panic and recover（恐惧和恢复）</h2>

<p>panic（恐慌）是一个运行时错误，展开goroutine的堆栈，一路运行任何递延的功能，然后停止程序。恐慌与Java异常相似，但只适用于运行时的错误，如一个nil 指针或试图索引数组越界。 Go程序使用内置的error类型 （详见上文）为了表示如文件结束等事件。</p>

<p>可以使用内置的recover （恢复），重新获得控制权的恐慌的goroutine和恢复正常运行。呼叫recover停止展开，并返回传入的参数panic。因为只有运行的未展开代码，内部含有延迟函数，recover只在内递延的函数有效。如果的goroutine是没有恐慌，recover返回nil。</p>

<h2>Go的线程机制和管道</h2>

<h3>Goroutines（Go的线程机制）</h3>

<p>Go允许用go开启一个新的执行线程--goroutine。它运行在不同的，新创建的的goroutine中。在一个程序中的所有goroutine共享相同的地址空间。</p>

<p>Goroutines是轻量级的，只占用比堆栈分配多一点的空间。堆栈开始小和成长的分配和释放堆（heap）的要求。内部goroutines像进行了复用多个操作系统线程的协程。您不必担心这些细节。</p>

<pre><code>go list.Sort()  // Run list.Sort in parallel; don’t wait for it.
</code></pre>

<p>Go处理文字的函数，可以作为结束，在处理go时很强大</p>

<pre><code>func Publish(text string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(text)
    }()  // Note the parentheses. We must call the function.
}
</code></pre>

<p>变量text和delay在周围函数和函数文字之间共享;只要它们都可以访问，它们就存在。</p>

<h3>Channels（管道）</h3>

<p>管道通过指定的元素类型的值来提供两个goroutine同步执行和沟通的机制。 &lt;- 操作符指定通道的方向，发送或接收。如无任何指示方向时，通道是双向的。</p>

<pre><code>chan T          // can be used to send and receive values of type T
chan&lt;- float64  // can only be used to send float64s
&lt;-chan int      // can only be used to receive ints
</code></pre>

<p>管道是一个引用类型，用make分配。</p>

<pre><code>ic := make(chan int)        // unbuffered channel of ints
wc := make(chan *Work, 10)  // buffered channel of pointers to Work
</code></pre>

<p>To receive a value on a channel, use it as a unary operator. 使用&lt;- 作为一个二元操作符来在管道上发送值。当在管道上接收一个值时，把它作为一元运算符。</p>

<pre><code>ic &lt;- 3       // Send 3 on the channel.
work := &lt;-wc  // Receive a pointer to Work from the channel.
</code></pre>

<p>如果管道是无缓冲，那么发送者阻塞，直到接收器接收到值。如果管道有一个缓冲区，发送者阻塞，直到该值已被复制到缓冲区。如果缓冲区已满，这意味着等待，直到一些接收器中检索到值。接收器被阻塞，直到有数据接收。</p>

<h2>并发 (示例)</h2>

<p>最后我们用一个例子来说明如何散落的内容拼起来。这是一个服务器通过管道来接受的Work请求的例子。每个请求都在一个单独的goroutine运行。 Work 结构本身包含了一个管道，用于返回一个结果。</p>

<pre><code>package server

import "log"

// New creates a new server that accepts Work requests
// through the req channel.
func New() (req chan&lt;- *Work) {
    wc := make(chan *Work)
    go serve(wc)
    return wc
}

type Work struct {
    Op    func(int, int) int
    A, B  int
    Reply chan int  // Server sends result on this channel.
}

func serve(wc &lt;-chan *Work) {
    for w := range wc {
        go safelyDo(w)
    }
}

func safelyDo(w *Work) {
    // Regain control of panicking goroutine to avoid
    // killing the other executing goroutines.
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(w)
}

func do(w *Work) {
    w.Reply &lt;- w.Op(w.A, w.B)
}
</code></pre>

<p><a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/src/server/server.go">server.go</a>
下面展示如何使用：</p>

<pre><code>package server_test

import (
    server "."
    "fmt"
)

func main() {
    s := server.New()

    divideByZero := &amp;server.Work{
        Op:    func(a, b int) int { return a / b },
        A:     100,
        B:     0,
        Reply: make(chan int),
    }
    s &lt;- divideByZero

    add := &amp;server.Work{
        Op:    func(a, b int) int { return a + b },
        A:     100,
        B:     200,
        Reply: make(chan int),
    }
    s &lt;- add

    fmt.Println(&lt;-add.Reply)
    // Output: 300
}
</code></pre>

<p><a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/src/server/example_test.go">example_test.go</a>
并发编程是一个大主题，Java和Go的方法是完全不同的。要想充分体验到并发编程的乐趣，看这篇<a href="http://golang.org/doc/codewalk/sharemem/">Share Memory by Communicating（《通过沟通共享内存》）</a></p>

<p>Stefan Nilsson</p>

<p>该文基于相似的文章 <a href="http://code.google.com/p/go-wiki/wiki/GoForCPPProgrammers">《面向C++的GO编程》</a></p>

<p>参考： <a href="http://www.nada.kth.se/~snilsson/goforjava_programmers">http://www.nada.kth.se/~snilsson/goforjava_programmers</a></p>

      <div class="readall"><a href="/go-for-java-programmers-java-developer-oriented-go-programming/" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="pagination">
  
  
  <a class="pagination-item newer" href="/page/19"><i class="fa fa-arrow-left"></i>&nbsp;&nbsp;上一页</a>
  
    

    
      <a href="/">1</a>
      

    
      
      <a href="/page/2">2</a>
      
    
      
      <a href="/page/3">3</a>
      
    
      
      <a href="/page/4">4</a>
      
    
      
      <a href="/page/5">5</a>
      
    
      
      <a href="/page/6">6</a>
      
    
      
      <a href="/page/7">7</a>
      
    
      
      <a href="/page/8">8</a>
      
    
      
      <a href="/page/9">9</a>
      
    
      
      <a href="/page/10">10</a>
      
    
      
      <a href="/page/11">11</a>
      
    
      
      <a href="/page/12">12</a>
      
    
      
      <a href="/page/13">13</a>
      
    
      
      <a href="/page/14">14</a>
      
    
      
      <a href="/page/15">15</a>
      
    
      
      <a href="/page/16">16</a>
      
    
      
      <a href="/page/17">17</a>
      
    
      
      <a href="/page/18">18</a>
      
    
      
      <a href="/page/19">19</a>
      
    
      
      <span class="current-page">20</span>
      
    
      
      <a href="/page/21">21</a>
      
    
      
      <a href="/page/22">22</a>
      
    
  (共129篇)

  
  <a class="pagination-item older" href="/page/21">下一页&nbsp;&nbsp;<i class="fa fa-arrow-right"></i></a>
  
</div>

    <footer>Copyright&nbsp;&copy;&nbsp;2014 <a href="http://www.waylau.com">Way Lau's Blog</a><br/><i class="fa fa-cogs" style="color:blueviolet;">&nbsp;</i>Powered by <a href="https://github.com/waylau/jekyll-theme-blog" target="_blank">jekyll-theme-blog</a></footer>
    </div>


  </div>    
  <div id="top"><a id="rocket" href="javascript:;" title="返回顶部"><i></i></a></div>
  


</body>
</html>