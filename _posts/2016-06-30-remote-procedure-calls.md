---
layout: post
title: 远程过程调用(RPC)详解
date: 2016-06-30 01:41
author: admin
comments: true
categories: [RPC]
tags: [Web,RPC]
---

本文介绍了什么是远程过程调用(RPC)，以及实现远程过程调用(RPC)有哪些常用的方法。

<!-- more -->

## 什么是 RPC 

RPC 是远程过程调用（Remote Procedure Call）的缩写形式，Birrell 和 Nelson 在 1984 发表于 ACM Transactions on Computer Systems 的论文《Implementing remote procedure calls》对 RPC 做了经典的诠释。RPC 是指计算机 A 上的进程，调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。而这一过程，对于开发人员来说是透明的。

![图1 描述了数据报在一个简单的RPC传递的过程](/images/post/20160630-rpc.png)
 
图1 描述了数据报在一个简单的RPC传递的过程
 
注：上述论文，可以在线阅读 <http://www.cs.virginia.edu/~zaher/classes/CS656/birrel.pdf>。


远程过程调用采用客户机/服务器(C/S)模式。请求程序就是一个客户机，而服务提供程序就是一台服务器。和常规或本地过程调用一样，远程过程调用是同步操作，在远程过程结果返回之前，需要暂时中止请求程序。使用相同地址空间的低权进程或低权线程允许同时运行多个远程过程调用。

## RPC 的基本操作

让我们看看本地过程调用是如何实现的。考虑下面的 C 语言的调用：

```c
count = read(fd, buf, nbytes);
```

其中，fd 为一个整型数，表示一个文件。buf 为一个字符数组，用于存储读入的数据。 nbytes 为另一个整型数，用于记录实际读入的字节数。如果该调用位于主程序中，那么在调用之前堆栈的状态如图2(a)所示。为了进行调用，调用方首先把参数反序压入堆栈，即为最后一个参数先压入，如图2(b)所示。在 read 操作运行完毕后，它将返回值放在某个寄存器中，移出返回地址，并将控制权交回给调用方。调用方随后将参数从堆栈中移出，使堆栈还原到最初的状态。

![图2 过程调用中的参数传递](/images/post/20160630-lpc.png)

图2 过程调用中的参数传递

RPC 背后的思想是尽量使远程过程调用具有与本地调用相同的形式。假设程序需要从某个文件读取数据，程序员在代码中执行 read 调用来取得数据。在传统的系统中， read 例程由链接器从库中提取出来，然后链接器再将它插入目标程序中。 read 过程是一个短过程，一般通过执行一个等效的 read 系统调用来实现。即，read 过程是一个位于用户代码与本地操作系统之间的接口。

虽然 read 中执行了系统调用，但它本身依然是通过将参数压入堆栈的常规方式调用的。如图2(b)所示，程序员并不知道 read 干了啥。

RPC 是通过类似的途径来获得透明性。当 read 实际上是一个远程过程时（比如在文件服务器所在的机器上运行的过程），库中就放入 read 的另外一个版本，称为客户存根（client stub）。这种版本的 read 过程同样遵循图2(b)的调用次序，这点与原来的 read 过程相同。另一个相同点是其中也执行了本地操作系统调用。唯一不同点是它不要求操作系统提供数据，而是将参数打包成消息，而后请求此消息发送到服务器，如图3所示。在对 send 的调用后，客户存根调用 receive 过程，随即阻塞自己，直到收到响应消息。

![图3 客户与服务器之间的RPC原理](/images/post/20160630-cs-rpc.png)
 
图3 客户与服务器之间的RPC原理

当消息到达服务器时，服务器上的操作系统将它传递给服务器存根（server stub）。服务器存根是客户存根在服务器端的等价物，也是一段代码，用来将通过网络输入的请求转换为本地过程调用。服务器存根一般先调用 receive ，然后被阻塞，等待消息输入。收到消息后，服务器将参数由消息中提取出来，然后以常规方式调用服务器上的相应过程（如图3所示）。从服务器角度看，过程好像是由客户直接调用的一样：参数和返回地址都位于堆栈中，一切都很正常。服务器执行所要求的操作，随后将得到的结果以常规的方式返回给调用方。以 read 为例，服务器将用数据填充 read 中第二个参数指向的缓冲区，该缓存区是属于服务器存根内部的。

调用完后，服务器存根要将控制权教会给客户发出调用的过程，它将结果（缓冲区）打包成消息，随后调用 send 将结果返回给客户。伺候，服务器存根一般会再次调用 receive，等待下一个输入的请求。

客户机器接收到消息后，客户操作系统发现该消息属于某个客户进程（实际上该进程是客户存根，知识操作系统无法区分二者）。操作系统将消息复制到相应的缓存区中，随后解除对客户进程的阻塞。客户存根检查该消息，将结果提取出来并复制给调用者，而后以通常的方式返回。当调用者在 read 调用进行完毕后重新获得控制权时，它所知道的唯一事就是已经得到了所需的数据。它不指导操作是在本地操作系统进行，还是远程完成。

整个方法，客户方可以简单地忽略不关心的内容。客户所涉及的操作只是执行普通的（本地）过程调用来访问远程服务，它并不需要直接调用 send 和 receive 。消息传递的所有细节都隐藏在双方的库过程中，就想传统库隐藏了执行实际系统调用的细节一样。

概况来说，远程过程调用包含如下步骤：

1. 客户过程以正常的方式调用客户存根；
2. 客户存根生成一个消息，然后调用本地操作系统；
3. 客户端操作系统将消息发送给远程操作系统；
4. 远程操作系统将消息交给服务器存根；
5. 服务器存根调将参数提出出来，而后调用服务器；
6. 服务器执行要求的操作，操作完成后将结果返回给服务器存根；
7. 服务器存根将结果打包成一个消息，而后调用本地操作系统；
8. 服务器操作系统将含有结果的消息发送给客户端操作系统；
9. 客户端操作系统将消息交给客户存根；
10. 客户存根将结果从消息中提取出来，返回给调用它的客户存根。

以上步骤就是将客户过程对客户存根发出的本地调用转换成对服务器过程的本地调用，而客户和服务器都不会意识到中间步骤的存在。


RPC 的主要好处是双重的。首先,程序员可以使用过程调用语义来调用远程函数并获取响应。其次,简化了编写分布式应用程序的难度,因为 RPC 隐藏了所有的网络代码存根函数。应用程序不必担心一些细节,比如 socket、端口号以及数据的转换和解析。在 OSI 参考模型,RPC 跨越了会话层和表示层。

## 实现远程过程调用

要实现远程过程调用，需考虑以下几个问题。

### 如何传递参数

#### 传递值参数

传递值参数比较简单，下图图展示了一个简单 RPC 进行远程计算的例子。其中，远程过程 add(i,j) 有两个参数 i 和 j， 其结果是返回 i 和 j 的算术和。


![图4 通过RPC进行远程计算的步骤](/images/post/20160630-rpc-compute.png)

图4 通过RPC进行远程计算的步骤

通过 RPC 进行远程计算的步骤有：
* 将参数放入消息中，并在消息中添加要调用的过程的名称或者编码。
* 消息到达服务器后，服务器存根堆该消息进行分析，以判明需要调用哪个过程，随后执行相应的调用。
* 服务器运行完毕后，服务器存根将服务器得到的结果打包成消息送回客户存根，客户存根将结果从消息中提取出来，把结果值返回给客户端。

当然，这里只是做了简单的演示，在实际分布式系统中，还需要考虑其他情况，因为不同的机器对于数字、字符和其他类型的数据项的表示方式常有差异。比如整数型，就有 Big Endian 和 Little Endian 之分。

#### 传递引用参数


传递引用参数相对来说比较困难。传递引用（也包含指针）是完全没有意义的，因为地址传递给远程计算机,其指向的内存位置可能跟远程系统上完全不同。如果你想支持传递引用参数,你必须发送参数的副本,将它们放置在远程系统内存中,向他们传递一个指向服务器的功能的指针,然后将对象发送回客户端,复制它的引用。如果远程过程调用必须支持引用复杂的结构,比如树和链表,他们需要将结构复制到一个无指针的表示里面（比如,一个扁平的树),并传输到在远程端来重建数据结构。

#### 如何表示数据?

在本地系统上没有数据不相容问题,数据格式总是相同的。而在分布式系统中，不同远程机器上可能有不同的字节顺序，不同大小的整数,以及不同的浮点表示。对于 RPC,如果想与异构系统通信，我们就需要想出一个“标准”来对所有数据类型进行编码,并可以作为参数传递。例如,ONC RPC 使用 XDR (eXternal Data Representation) 格式 。这些数据表示格式可以使用隐式或显式类型。隐式类型,是指只传播值,而不传递变量的名称或类型。常见的例子是 ONC RPC 的XDR 和 DCE RPC 的 NDR。显式类型,指需要传播每个字段的类型以及值。常见的例子是 ISO 标准 ASN.1 (Abstract Syntax Notation)、JSON (JavaScript Object Notation)、Google Protocol Buffers、以及各种基于 XML 的数据表示格式。
 
#### 如何选用传输协议?

有些实现只允许使用一个协议(例如 TCP )。大多数 RPC 实现支持几个，并允许用户选择。

#### 出错时,会发生什么?

相比于本地过程调用，远程过程调用出错的机会将会更多。由于本地过程调用没有过程调用的失败的概念,项目使用远程过程调用必须准备测试远程过程调用的失败或捕获异常。

#### 远程调用的语义是什么?

调用一个普通的过程语义很简单:当我们调用时，过程被执行。远程过程完全一次性调用成功是非常难以实现。执行远程过程可以有如下结果:

* 如果服务器崩溃或进程在运行服务器代码之前就死了，那么远程过程会被执行0次；
* 如果一切工作正常，远程过程会被执行1次；
* 如果服务器返回服务器存根后在发送响应前就奔溃了，远程过程会被执行1次或者多次。客户端接收不到返回的响应,可以决定再试一次,因此出现多次执行函数。如果没有再试一次,函数执行一次；
* 如果客户机超时和重新传输，那么远程过程会被执行多次。也有可能是原始请求延迟了。两者都可能会执行或不执行。

RPC 系统通常会提供至少一次或最多一次的寓意，或者在两者之间选择。如果需要了解应用程序的性质和功能的远程过程是否安全，可以通过多次调用一个函数来验证。如果一个函数可以运行任何次数而不影响结果,这是幂等（idempotent）函数的，如每天的时间、数学函数、读取静态数据等)。否则,它是一个非幂等（nonidempotent）函数，如添加或修改一个文件)。

性能怎么样?
常规过程调用快:通常只有少数指令周期。远程过程调用呢?认为额外的步骤。调用客户端存根函数,得到一个从退货过程调用的开销。最重要的是,我们需要执行代码元帅参数,调用操作系统的网络程序(导致模式切换和上下文切换),处理网络延迟,让服务器接收消息,并切换到服务器进程,数据参数,调用服务器功能,做一遍回程。毫无疑问,一个远程过程调用将会慢得多。我们可以很容易的期望进行删除调用的开销低于本地数千倍。然而,不应该阻止我们使用远程过程调用,因为通常有强有力的理由移动到服务器的功能。

安全呢?
这绝对是我们需要担心的事情。与当地程序的范围内所有的函数调用是一个过程,我们预计操作系统应用足够的内存保护通过每个进程的内存映射,以便其他进程无法得知操纵或检查函数调用。与RPC,我们必须关注各种安全问题:

是客户端发送消息到正确的远程过程或过程是一个骗子吗?

是客户端发送消息到正确的远程计算机或远程机器是一个骗子吗?

服务器只接受消息从合法客户端吗?可以在客户端服务器识别用户?

时被其他进程的消息可以嗅遍历网络吗?

可以由其他进程消息被拦截和修改时遍历网络从客户端到服务器或服务器端?

协议受制于重播攻击吗?即可以恶意主机获取消息重新发送它在稍后的时间吗?

消息被意外损坏或截断,而网络上的?

编程与远程过程调用
图2。远程过程调用编译步骤
图2。远程过程调用编译步骤
今天许多流行的语言(C、c++、Python计划,et艾莉雅)设计时没有内置的远程程序的语法,因此不能产生必要的存根函数。启用远程过程调用的使用这些语言,通常采用的解决方案是提供一个单独的编译器生成客户机和服务器存根函数。这个编译器将���输入从一个programmer-specified定义的远程过程调用接口。这样的定义写在一个接口定义语言。

接口定义通常类似于函数原型声明:它列举了函数输入和返回参数集。RPC运行编译器后,客户端和服务器程序可以被编译并与适当的存根函数(图2)。客户端程序已被修改成initiallyize RPC机制(如定位服务器和可能建立一个连接)和处理远程过程调用的失败。

RPC的优点
你不必担心被一个独特的传输地址(选择一个独特的端口号为套接字机)。服务器可以绑定到任何可用的端口,然后注册端口与RPC服务器名称。客户端将接触这个名字服务器找到对应的端口号所需要的程序。这将是无形的程序员。

系统可以独立于传输提供者。自动生成服务器存根可以使本身可以在系统上的每一个运输供应商,TCP和UDP。客户端可以选择动态,不需要额外的编程代码来发送和接收消息是自动生成的。

应��程序在客户端只需要知道一个运输地址:的名称服务器负责告诉应用程序,连接服务器对于一个给定的函数集。

可以使用函数调用模型而不是发送/接收(读/写)接口提供的套接字。用户不需要处理编组参数,然后解析出来在另一边。

RPC API
任何RPC实现需要提供一组支持库。这些包括:

名称服务操作
注册和查找绑定信息(港口、机器)。允许一个应用程序使用动态(操作系统分配)端口。
绑定操作
建立客户机/服务器通信使用适当的协议(建立通信端点)。
终端操作
注册端点信息(协议、端口号、机器名)的名称服务器并监听过程调用请求。这些函数通常被称为从自动生成的主程序,服务器存根(骨架)。
安全操作
系统应该提供客户端和服务器的机制能够相互验证,两者之间提供一个安全的通信通道。
国际化运营(可能)
这是很少的一部分RPC包但可能包括功能转换时间格式,货币格式和特定于语言的字符串在字符串表。
封送处理/数据转换操作
函数将数据序列化到一个平面的字节数组传递到网络和功能重建。
存根内存管理和垃圾收集
存根可能需要分配内存来存储参数,特别是模拟引用传递语义。RPC包需要分配和清理任何这样的分配。他们也可能需要为创建网络分配内存缓冲区。RPC包支持对象,RPC系统需要一种跟踪远程客户端是否仍有引用对象或一个对象是否可以删除。
程序标识操作
允许应用程序访问标识符(或处理)的RPC接口,这样的接口提供的服务器可以交流和使用它。
ID对象和功能操作
允许的能力对远程函数或远程对象的引用传递给其他进程。并不是所有的RPC系统支持。
第一代远程过程调用
ONC RPC(以前太阳RPC)
太阳微系统公司是第一个商业产品的RPC库和RPC编译器。提出在太阳计算机在1980年代中期和太阳的网络文件系统(NFS)的支持。该协议被作为一个标准的开放网络计算,为首的一个财团太阳和AT&T。这是一个非常轻量级(和光)RPC系统可用在大多数POSIX和POSIX-like操作系统,包括Linux,SunOS,OS X和各种口味的BSD。这是通常被称为太阳RPC或ONC RPC。

ONC RPC提供了一个编译器,需要一个远程过程接口的定义和生成客户机和服务器存根函数。这个编译器叫做rpcgen。在运行此编译器之前,程序员必须提供接口定义。包含函数声明的接口定义,分组通过版本号和被一个独特的项目号码。程序使客户数量来确定所需的接口。版本号是有用的,让客户没有更新到最新的代码仍然可以连接到一个新的服务器,服务器还支持旧接口。

通过网络参数转化成一种隐式类型序列化格式被称为XDR(外部数据表示)。这将确保参数发送到异构系统可能使用不同的字节顺序,不同大小的整数,或不同的浮点或字符串表示。最后,太阳RPC运行时库提供了一个实现必要的支持RPC协议和套接字例程。

所有的程序员都写是一个客户端程序(client.c),服务器功能(server.c)和RPC接口定义(date.x)。当RPC接口定义(一个文件后缀为。x;例如,一个名为date.x)是用rpcgen编译的文件,创建三个或四个文件。这些日期。x的例子:

date.h
包含项目的定义、版本和声明的函数。客户端和服务器端功能应该包括这个文件。
date_svc.c
C代码来实现服务器存根。
date_clnt.c
C代码来实现客户端存根。
date_xdr.c
包含XDR例程将数据转化为XDR格式。如果这个文件生成,它应该编译和链接在客户端和服务器的功能。
创建客户端和服务器可执行文件的第一步是编译数据定义文件date.x。之后,客户端和服务器端功能可能是编译和链接的各自的rpcgen生成的存根函数。

在旧版本的,传输协议将字符串“tcp”或字符串“udp”指定各自的IP服务RPC。这是仍然支持,必须使用的Linux实现RPC。使界面更加灵活,UNIX系统V版本4(SunOS从版本5)网络选择程序允许一个更一般的规范。他们搜索文件(/ etc / netconfig)第一供应商能够满足您的需求。最后一个参数可以是:

“netpath”
搜索NETPATH环境变量序列的首选运输提供商)
“circuit_n”
找到第一个虚拟电路提供商NETPATH列表),“datagram_n”(找到第一个数据报供应商NETPATH列表)
“可见”
找到第一个可见交通提供者/etc/netconfig)
“circuit_v”
找到第一个可见虚拟电路传输提供者/etc/netconfig)
“datagram_v”
找到第一个可见数据报传输提供者/etc/netconfig)。
每个远程过程调用最初仅限于接受一个输入参数和RPC处理。系统只是后来修改为支持多个参数。支持单一参数RPC仍然是默认rpcgen的一些版本,比如苹果的OS x传递多个参数必须通过定义一个结构,包含所需的参数,初始化,并通过结构。

远程过程调用返回一个指针指向结果而不是期望的结果。服务器功能必须修改接受一个指针(RPC中声明的价值定义。x文件)作为输入,并返回一个指向结果值。在服务器上,必须是一个指针指向静态数据的指针。否则,指出的区域将未定义当程序返回和释放过程的框架)。在客户端,一个指针的回归让我们区分一个失败的RPC(空指针)和一个空返回从服务器(间接空指针)。

RPC程序名称的名称在RPC定义文件转换为小写和后缀下划线,后跟一个版本号。例如,BIN_DATE bin_date_1成为引用函数。您的服务器必须实现bin_date_1和客户端代码调用bin_date_1应该问题。

当我们运行这个程序时,会发生什么?
服务器
当我们启动服务器,服务器存根代码(程序)在后台运行并将流程(别忘了运行ps找到并杀死它,当你不再需要它[1])。它创建一个套接字并将任何本地端口绑定套接字。然后调用一个函数在RPC库,svc_register,登记程序数量和版本。这个联系人端口映射器。端口映射器是一个独立的过程,通常是在系统启动时启动。它跟踪端口号,版本号,项目数量。在UNIX系统V版本4,这个过程称为rpcbind。在Linux上,OS X,和BSD系统,它被称为portmap。

图3。函数查找ONC RPC
图3。函数查找ONC RPC
客户端
当我们开始客户端程序时,它首先调用clnt_create远程系统的名称,项目编号,版本号,和协议。它接触远程系统上的端口映射器,系统上找到合适的港口。

然后客户端调用RPC存根函数(在本例中bin_date_1)。该函数发送一条消息(如。数据报)服务器(使用的端口号)早些时候发现并等待响应。数据报服务,它将重新发送请求一个固定的次数是否没有收到响应。

消息接收到远程系统,它调用服务器函数(bin_date_1)并将返回值返回给客户端存根。客户端存根然后返回到客户端发出调用的代码。

RPC在分布式计算环境(DCE RPC)
分布式计算环境(DCE)是一组组件设计的开放软件基金会(OFS)提供支持分布式应用和分布式环境中。与X /开放合并后,这群成为开放组织。DCE的一部分提供的组件包括一个分布式文件服务,每次服务目录,服务,和其他几个人。我们感兴趣的是DCE远程过程调用。它非常类似于太阳RPC。接口都写在一个名为接口定义的接口定义语言符号(IDN)。像太阳RPC接口定义函数原型。

缺一个太阳RPC服务器的标识有“独特”的32位数字。虽然这是一个更大的空间比16位数字可用空间在套接字,还不安慰想出一个号码,希望它是独一无二的。DCE RPC地址这一缺陷,没有程序员想出一个数字。在编写一个应用程序的第一步是获得与uuidgen计划一个惟一的ID。这个程序会生成一个包含一个接口原型申请文件ID保证永远不会再使用。它是一个128位的值,其中包含一个位置编码的代码和创建时间。然后用户编辑原型文件,填写远程过程声明。

在这一步中,印度尼西亚的编译器,dceidl,类似于rpcgen,生成一个头,客户机存根和服务器存根。

太阳RPC的另一个缺陷是,客户端必须知道服务器所在的机器上。然后可以问RPC名称服务器机器上的程序数量对应的端口号,它希望访问。DCE支持几个机器的组织为管理实体,称为细胞。每台机器知道如何与一台机器负责维护细胞的信息服务:细胞目录服务器。

图4。在DCE RPC函数查找
图4。在DCE RPC函数查找
与太阳RPC服务器只有注册其{程序号端口映射}与本地名称服务器(portmapper)。在DCE服务器注册其端点(港口)在本地机器上RPC守护进程(名称服务器)以及寄存器机器} {程序名映射单元目录服务器。当客户机想要与一个RPC服务器建立通信,它首先要求其细胞目录服务器定位服务器所在的机器。然后客户端谈判RPC守护进程,机器上服务器进程的端口号。DCE跨细胞还支持更复杂的搜索。

DCE RPC定义了名为NDR军事化管理消息,网络编码对网络数据表示。与一个单一的规范代表不同的数据类型,NDR支持multi-canonical格式。几种编码方法允许客户端可以挑选择,理想的情况是不需要它将从本地类型。如果这不同于服务器的本地数据表示,服务器将仍然需要转换但multi-canonical格式可以避免在客户端和服务器的情况下转换为外部格式时他们都共享相同的本地格式。例如,如果一个标准规定大端字节序网络数据格式,但客户端和服务器支持小端字节序,客户端必须将每个数据从小端字节序big endian和服务器,接到消息,将每个数据回小端字节序。multi-canonical网络数据表示将允许客户端发送网络消息包含小端字节格式的数据。

第二代rpc:对象支持
面向对象的语言开始获得声望在1980年代末,很明显,这两个太阳(ONC)和DCE RPC系统没有提供任何支持实例化远程对象从远程类,跟踪对象的实例,或提供支持多态性[2]。现有的RPC机制仍然运作但他们不支持面向对象编程技术在自动、透明的方式进行。

微软DCOM(COM +)
1992年4月,微软发布Windows 3.1包括一种机制称为OLE(对象链接和嵌入)。这允许一个程序动态链接库,允许的其他设施,如将一个电子表格嵌入到Word文档(这不是微软创新;他们迎头赶上一个功能已经由苹果公司提供)。OLE演变成一种叫做COM(组件对象模型)。一个COM对象是一个二进制文件。使用COM服务访问的程序标准化接口的COM对象而不是其内部结构。COM对象命名与全局唯一标识符(guid)和类对象与类的id。几种方法来创建一个COM对象(例如CoGetInstanceFromFile)。COM库查找相应的二进制代码(一个DLL[3]或可执行文件)在系统注册表中,创建对象,并向调用者返回一个接口指针。

介绍了DCOM(分布式COM)与Windows NT 4.0在1996年和组件对象模型的扩展允许对象之间通信的机器。这是后来重新命名为COM +。自DCOM是为了支持访问远程COM对象,这一过程需要创建一个对象需要供应网络的名称服务器以及类ID。微软提供了一些机制来实现这一点。最透明的是远程机器的名字固定在注册表中(或DCOM类商店),与特定类关联ID。这种方式,应用程序不知道访问远程对象,可以使用相同的接口指针,它将为当地的COM对象。或者,一个应用程序可以指定机���名称作为参数。

DCOM服务器在运行时服务对象的能力。一个服务被称为“服务控制管理器(SCM),DCOM库的一部分,负责连接到服务器端SCM和请求服务器上创建的对象。在服务器上,代孕过程负责加载组件和运行它们。这不同于RPC模型如ONC和DCE服务为一个特定的接口不是先天的开始。这个代理过程能够同时处理多个客户。

支持类的特定实例的标识(单个对象),DCOM对象提供了一个称为绰号命名功能。每个实例一个对象可以创建自己的名称并将其传递回客户端。客户端就可以引用它后或通过其他进程的绰号。一个绰号本身是一个对象。其IMoniker接口可以用于定位,激活和访问绑定ob-ject没有任何对象的位置信息。

支持多种类型的名字:

文件名字
这个绰号使用文件类型(如。. doc”)来确定合适的对象(如。Microsoft Word)。微软支持持久性:存储对象的数据在一个文件中。如果一个文件代表一个存储对象,DCOM将使用文件中的类ID来识别对象。
URL的绰号
这抽象访问url通过Internet协议(如http、https、ftp)一个COM接口。绑定一个URL绰号允许远程数据检索。在内部,URL绰号使用经由WinInet API来检索数据。
类的名字
这是与其他名字一起使用,覆盖类ID查找机制。
在DCOM:ORPC
微软DCOM本身不提供远程过程调用功能。它是一组库假定RPC系统是可用的。在DCOM是微软的RPC机制,称为对象RPC(ORPC)。这是一个轻微的DCE RPC协议的扩展与补充支持一个接口指针标识符(IPID),版本信息,信息和可扩展性。接口指针标识符用于识别一个特定类的实例调用将被处理。它还提供了推荐的能力——远程对象引用(IPIDs)可以传递。

封送处理机制是相同的网络数据表示(NDR)在DCE RPC与一个新类型代表一个军事化管理界面(IPID)。编组,DCOM(ORPC)需要知道方法、参数和数据结构。这是来自一个接口定义语言,称为MIDL,微软的接口定���语言。正如所料,这是相同的DCE与扩展定义对象的申请。MIDL文件使用IDL编译器编译,生成c++代码用于封送和解封。客户端调用代理和服务器端称为存根。两者都是COM对象,可以由COM加载库。

远程引用计数
服务器之间的主要区别面向对象编程和基于函数的编程功能持续而从他们的类对象的实例化和删除(代码库仍固定,但数据区域分配每次创建一个对象)。服务器,这意味着它必须准备创建新的对象和知道何时释放内存(破坏对象)当对象不再需要(没有其他引用留给对象)。

微软DCOM这是否明确而不是自动。对象生命周期由远程引用计数控制。一个调用RemAddRef当新的引用一个对象添加和移除RemRelease当参考。服务器上的对象本身被删除时,引用计数为0。

这种机制没问题但并非万无一失。如果一个客户端异常终止,没有消息被发送到的对象的引用计数递减客户机使用。处理这种情况下,服务器的同事一个过期时间为每个对象和依赖周期性消息从客户端保持对象引用的活着。这个机制被称为震性。服务器维护一个ping频率(pingPeriod)和超时时间(numPingsToTimeOut)。客户端运行一个后台进程发送一套平:所有远程对象的id在特定服务器上。如果超时周期到期没有ping收到,所有的引用被清除。

DCOM总结
微软DCOM RPC系统早是一个重大的改进。对象RPC层是一个增量的改进/ DCE RPC和允许对象引用。DCOM层基于COM的访问对象(通过函数表),并提供访问远程对象的透明度。远程引用管理仍有些问题,它必须显式地完成但至少有一个机制来支持这个。绰号机制提供了一个COM接口以支持命名对象,是否远程引用,对象存储在文件系统中,或url。最大的缺点是DCOM是微软的解决方案。它也不能穿过防火墙的工作(大多数RPC系统的问题),因为防火墙必须允许交通流之间的某些ORPC所使用的端口和DCOM。

CORBA
即使DCE修复的一些缺点太阳RPC,某些缺陷依然存在。例如,如果一个服务器没有运行,客户端无法连接到远程过程调用。是管理员的责任,以确保所需的任何客户机试图连接到服务器之前开始。如果一个新服务或接口添加到系统,没有是一个客户端可以发现这一点。在某些环境中,它可能有助于客户能够了解在运行时服务及其接口。最后,面向对象语言期望多态性在函数调用(不同类型的数据的函数的行为可能有所不同)。传统的RPC没有支持。

CORBA(公共对象请求代理体系结构)是解决这些和其他问题。它是一种体系结构由一个行业300多家公司财团称为对象管理组织(OMG)。这个架构的规范自1989年以来一直在发展。我们的目标是提供对分布式异构的面向对象的应用程序的支持。对象可能是托管在一个网络的电脑(一个对象不是分布式)。该规范是独立于任何编程语言,操作系统或网络,使在这些平台互操作性。

在CORBA,当客户端希望调用一个对象上的一个操作(方法),它使一个请求和响应。请求和响应通过对象请求代理(ORB)。ORB代表整个的界面库,存根函数,和服务器隐藏通信机制,激活,从客户端和存储的服务器对象。它允许对象在运行时发现对方和调用服务。

当客户端发出请求时,ORB:

执法官参数(客户端)。
定位服务器对象。如果有必要的话,它会创建一个过程在服务器处理请求。
如果服务器是远程,传送请求(使用RPC或套接字)。
对参数为服务器格式(在服务器上)。
警察返回值(在服务器上
如果服务器是远程传输返回。
对结果在客户端。
一个接口定义语言(IDL)用于指定类的名字,他们的属性和方法。它不包含对象的实现。IDL编译器生成代码来处理编组,解封,ORB /网络交互。它生成客户机和服务器存根。IDL是编程语言中立。绑定存在许多种,包括C、c++、Java、Perl、Python、Ada、COBOL、Smalltalk,Objective - C,口齿不清。一个示例IDL如下所示:

Module StudentObject {
    Struct StudentInfo {
        String name;
        int id;
        float gpa;
    };
    exception Unknown {};
    interface Student {
        StudentInfo getinfo(in string name)
            raises(unknown);
        void putinfo(in StudentInfo data);
    };
};
IDL数据类型包括:

基本类型:长、短字符串,浮动,…
构造类型:结构、工会、枚举、序列
类型的对象引用
任何类型:一个动态类型的值
编程是最常见的实现通过对象引用和请求:客户发出请求在CORBA对象使用对象引用和调用所需的方法。例如,使用IDL如上所示,一个可能的代码如:

Student st = ... // get object reference
try {
    StudentInfo sinfo = st.getinfo("Fred Grampp");
} catch (Throwable e) {
    ... // error
}
在幕后,IDL编译器生成的存根函数。这段代码导致调用存根函数,然后警察参数,并将它们发送到服务器。客户端和服务器可以使用存根只有类和方法的名称在编译时是已知的。否则,CORBA支持动态绑定:组装方法调用在运行时通过动态调用接口(DII)。这个接口提供了调用设置类,构建参数列表,使电话。服务器对应(用于创建一个服务器接口动态地)被称为动态框架接口(DSI)[4]。客户端可以在运行时发现的类和方法的名称通过接口库。这个名称服务器可以查询发现是什么类的服务器支持和对象实例化。

CORBA规范的功能接口和功能但是离开了实际实现和数据表示格式个人ORB供应商。这导致了一个CORBA实现可能的情况不一定能够与另一个。应用程序通常需要一些返工从一个供应商的CORBA产品转移到另一个。

1996年,CORBA 2.0规范中添加互操作性为目标。标准定义了一个名为IIOP的网络协议(Internet orb间协议)这将工作在任何基于TCP / IP的CORBA实现。事实上,因为终于有一个标准化的、记录协议,IIOP本身可用于系统甚至不提供一个CORBA的API。例如,它可以作为传输的实现Java RMI(RMI / IIOP)。

希望提供一个证据充分的网络协议,如CORBA IIOP的全功能的设置功能是开启一个广泛的多元化的互联网服务。组织可以主机CORBA-aware服务。客户在互联网上可以查询这些服务,找出他们的动态接口,调用函数。这些服务的广泛性可以像HTML web access无处不在。这并没有发生。基于http的web服务胜出。

CORBA的总结
基本上,CORBA构建在早些时候RPC系统并提供下列附加功能:

静态或动态方法调用(RPC)只支持静态绑定。
每一个ORB支持运行时元数据来描述每一个服务器接口系统。
ORB可以代理调用在一个过程中,多个进程在同一台机器上,或者分布式过程。
多态的消息传递:ORB调用一个函数在一个目标对象。相同的功能可能有不同的影响取决于对象的类型。
自动实例化对象不运行
与其他orb通信。
CORBA还提供了一组全面的服务(称为COS,CORBA服务)来管理对象:
生命周期服务:提供操作创建、复制、移动和删除组件。
持久性服务(外部化):提供一个接口,用于在存储服务器上存储组件。
命名服务:允许组件定位其他组件的名字。
事件服务:组件可以注册/注销他们的特定事件的兴趣。
并发控制服务:允许对象获取锁代表事务。
协调事务服务:提供两阶段提交(稍后将详细介绍这个协议)。
查询服务:允许对象的查询操作。
授权服务:允许计量使用的组件。
物业服务:允许名称/属性被关联到一个组件。
价格的能力和灵活性是复杂性。尽管CORBA���可靠和分布式服务管理提供了全面的支持,部署和使用CORBA一般,而陡峭的学习曲线。将它与语言并不总是直截了当。除非人能真正利用CORBA的功能,通常是更容易使用更简单和更少的强大的系统调用远程过程。CORBA享有体面程度的成功,但只有在池的用户而不是一个电子社区。CORBA在迟到标准化TCP / ip协议和部署基于互联网的服务。

Java RMI
CORBA旨在提供一组全面的服务来管理对象在异构环境中(不同语言、操作系统、网络)。Java,在其最初的《盗梦空间》,支持从远程站点下载的代码,但它只支持分布式通信是通过套接字。1995年,太阳(Java)的创造者开始创建一个扩展Java称为Java RMI(远程方法调用)。Java RMI允许程序员创建分布式应用程序可以调用远程对象的方法从其他Java虚拟机(jvm)。

可以进行远程调用一旦应用程序(客户端)对远程对象的引用。这是通过查找远程对象的命名服务(RMI注册中心)提供的RMI和接收作为返回值的引用。Java RMI在概念上类似于RPC对接支持对象调用的语义在不同地址空间。

Java的一个领域的设计不同于大多数RPC系统CORBA和RMI是构建Java。太阳RPC,DCE RPC,微软的COM +和ORPC和CORBA的设计语言,架构和操作系统(微软除外)独立。虽然这些功能丢失,增益是RMI干净符合语言和没有需要标准化的数据表示(Java到处都使用相同的字节次序)。Java RMI的设计目标应该是:

适应语言,集成到语言,易于使用。
支持无缝的远程调用对象。
支持回调服务器applet。
保存Java对象的安全环境。
支持分布式垃圾回收。
支持多种传输。
分布式对象模型类似于本地Java对象模型在以下方面:

引用一个对象可以作为参数传递或返回的结果。

远程对象可以投到任何支持的远程接口的集合的实现使用Java语法。

内置Java instanceof操作符可以用来测试远程对象支持的远程接口。

对象模型与本地Java对象模型的不同之处在于以下方面:

类的远程对象与远程接口交互,从来没有与这些接口的实现类。

Non-remote参数(结果)远程方法调用是通过复制,而不是引用。

通过远程对象引用,而不是实际的远程复制实现。

客户必须处理额外的异常。

接口和类
所有java.rmi.Remote远程接口扩展接口。例如:

public interface bankaccount extends Remote
{
    public void deposit(float amount)
        throws java.rmi.RemoteException;

    public void withdraw(float amount)
        throws OverdrawnException,
        java.rmi.RemoteException;
}
注意,每个方法必须声明java.rmi。远程异常抛出的条款。这个异常在客户端通过RMI系统只要远程方法调用失败。然后创建一个实现这些远程接口。

远程对象类
不可见的程序员,java.rmi.server。RemoteObject类提供了远程对象的语义通过实现hashCode、=和toString[5]。所需的函数创建对象,让他们可以远程由java.rmi.server提供。RemoteServer和子类。java.rmi.server。UnicastRemoteObject类定义了一个单播(单一)远程对象的引用是有效的只有当服务器进程还活着。

存根
图5。Java RMI流
图5。Java RMI流
Java RMI通过创建存根函数。存根和rmic编译器生成。Java 1.5以来,Java支持在运行时动态生成存根类。编译器、rmic仍然存在并支持并提供各种编译选项。

定位对象
提供了引导名称服务器用于存储命名对远程对象的引用。一个远程对象引用可以存储使用的基于url的方法类java.rmi.Naming。例如,

BankAccount acct = new BankAcctImpl();
String url = "rmi://java.sun.com/account";
// bind url to remote object
java.rmi.Naming.bind(url, acct);

// look up account
acct = (BankAccount)java.rmi.Naming.lookup(url);
RMI架构
图6。Java RMI逻辑视图
图6。Java RMI逻辑视图
RMI是一个三层架构(图6)。最上面一层是存根和骨架层。它传输数据到远程引用层通过元帅流。元帅流使用一个名为对象序列化的方法,使对象之间传输地址空间(通过他们的副本,除非他们通过远程对象的引用)。任何类,将作为一个参数用于远程方法必须实现serializable接口。这确保了对象数据(序列化)可以被转化为一个字节流(要素)通过网络传输。序列化是封送的一个核心方面:将数据转换成一串字节,以便它可以通过网络发送或存储在文件或数据库中。

客户端存根执行以下步骤:

启动远程对象调用
执法官参数
通知应调用远程引用层调用
对返回值或异常
通知远程引用层调用完成。
服务器存根(骨架):

对参数
使实际的远程对象实现返回值
执法官调用的返回值(或异常)
存根和骨架类在运行时确定并根据需要动态加载的。

远程引用层处理低层传输接口。它负责执行一个特定的远程引用协议独立的客户端服务器存根和骨架。

每个远程对象实现选择自己的远程引用子类。各种协议是可能的。例如:

单播点对点
调用复制对象组
支持一个特定的复制策略
支持持久远程对象引用(使激活远程对象的)
重新连接策略
RMI传输层是传输的协议栈的一部分。它:

建立连接,连接管理
显示器连接活性
监听来电
维护一个表的远程对象驻留在地址空间
设置为来电联系
定位的目标远程调用和传递到调度程序的连接。
RMI分布式垃圾回收
RMI创建一个分布式环境中,一个进程运行在一个Java虚拟机(JVM)可以访问对象居民在进程运行在不同的JVM(而且很可能不同的系统)。这意味着服务器进程需要知道当一个对象不再是由客户端和引用可以删除(垃圾收集)。在JVM中,Java使用引用计数和时间表对象的垃圾收集时,引用计数归零。在jvm,RMI,Java支持两种操作:脏和清洁。本地JVM定期发送一个肮脏的调用服务器的JVM对象时仍在使用。定期根据这个肮脏的调用是补发的租赁时间服务器。当客户端没有更多的本地引用远程对象,它发送一个干净调用服务器。与DCOM,服务器不需要计算每个客户机使用的对象,只是通知当一个对象不再需要。如果它不接收肮脏或干净的消息对象的租赁时间到期之前,然后安排对象删除。

第三代rpc和Web服务
由于使用互联网暴涨后推出的web浏览器,浏览器成为占主导地位的模型用于访问信息。设计的首要任务是提供用户通过浏览器访问,而不是编程访问访问或操作数据。

程序员渴望远程托管的服务项目,而不是用户可以使用。网页设计关注的内容。解析出表现方面往往是繁琐的。传统RPC解决方案可以工作在互联网上,但问题是,他们通常依赖于动态端口分配(联系名称服务器找出端口服务器提供一组特定的接口使用)。这是与最佳实践的防火墙配置,限制可用端口甚至可能检查协议保证,例如,HTTP流量确实是在一个有效的HTTP格式。

Web服务成为一组协议,允许发表,服务发现,用于技术无关的形式。即服务不应该依赖于客户的语言,操作系统,或机器架构。

共同实现的web服务是使用web服务器作为服务请求的管道。客户端访问该服务通过一个HTTP协议发送到服务器上的web服务器。web服务器配置识别URL的一部分路径名或文件名后缀并将请求传递给特定的浏览器插件模块。这个模块可以除去头,解析数据(如果需要),并根据需要调用其他函数或模块。这个流一个常见的例子是一个浏览器的支持Java servlet,在HTTP请求转发到JVM运行用户的服务器代码。

xml - rpc
XML - RPC是1998年作为一个RPC消息传递协议的请求和响应为人类可读的XML封送处理过程。XML格式使用显式输入和运输在HTTP协议,缓解了传统企业的防火墙问题为RPC服务器应用程序打开额外的端口。

xml - rpc消息的一个例子是:

<methodCall>
    <methodName>
        sample.sumAndDifference
    </methodName>
    <params>
        <param><value><int> 5 </int></value></param>
        <param><value><int> 3 </int></value></param>
    </params>
</methodCall>
这是一个请求运行方法命名为样本。sumAndDifference与两个整数参数:5和3。xml - rpc支持的基本数据类型是:整数、字符串、布尔值、双,dateTime.iso8601。此外,base64编码任意二进制数据类型和数组和结构允许一个定义数组和结构,分别。

xml - rpc没有设计时考虑到任何特定的语言,不是设计一套完整的软件来处理远程过程。存根生成、对象管理和服务查找不在协议。现在库对许多不同的语言,包括Apache xml - rpc Java、python和perl。其中的一些(如提供一个非常干净的过程接口。python和perl)。

xml - rpc是一个简单的规范(约7页)没有雄心勃勃的目标:它只关注消息和不处理垃圾收集,远程对象,远程过程的名称服务和其他方面。然而,即使没有广泛的产业支持,简单的协议导致广泛采用的协议。

肥皂
xml - rpc创建SOAP规范作为依据,曾经站从简单对象访问协议。首字母缩写已经下降由于协议不再是简单的和不限于访问对象。协议组成的一个财团组织成立于1998年的微软和IBM的大力支持。的最新版本是2007年。SOAP为无状态指定XML格式的消息交换,包括rpc样式的过程调用调用以及更一般的信息可能包括多个响应。

它继续在xml - rpc,提供用户定义的数据摘要,能够指定收件人,指定不同类型的消息,和更多的功能。通过HTTP SOAP主要是实现为XML消息。xml - rpc、SOAP是一种消息格式。对象引用,它没有定义垃圾收集存根一代,甚至传输协议。

SOAP成为流行的web服务的构建块。然而,它只是提供了一个标准化的消息结构。补充,需要一种方法来定义一个服务,这样可以创建正确的SOAP消息。WSDL、Web服务描述语言作为描述Web服务的方法。它是一个XML文档,可以喂给一个程序,将生成软件,发送和接收SOAP消息���实际上,WSDL作为接口定义语言,将生成存根(虽然,根据不同的语言,他们可能是也可能不是对程序员是透明的函数调用)。

WSDL文档包括四个部分:

类型:定义了web服务使用的数据类型。

消息:描述数据元素或参数,使用的消息。

端口类型:描述提供的业务服务。这包括操作和输入和输出消息(第2部分),每个操作使用。

绑定:为每个端口定义消息格式和协议细节。例如,它可以定义rpc样式的消息。注意港口一词在这里是一个抽象的消息端点(第3部分中定义的),而不是一个TCP或UDP端口号。

即使他们使用XML、SOAP和WSDL是供人类食用。通常情况下,一个程序员提供一个服务将创建一个接口定义在一些本地语言,如Java和使用工具如Java2WSDL或wsdl。exe创建一个WSDL文档。程序员想要使用一个服务将WSDL文档并运行它通过WSDL2Java等程序(一个apache Exclipse插件)或wsdllib(python)生成模板代码。

微软。NET Remoting
微软的COM +(DCOM)机制原本为嵌入对象在程序中动态和总是有些低级的实现。程序通常不得不提供显式引用计数和支持跨越语言和库是不均匀的。例如,Visual Basic为框架提供了大力支持,Visual c++需要更多的编程。微软检修和。net ehnaced这些机制。

微软的。网络由一个开发框架和运行时环境以创建平台无关的应用程序。。净API提供了一组类面向对象编程网络感知。公共中间语言(CIL)是一种基于堆栈的、低级的、面向对象的汇编语言,独立于机器,确保不同的语言和系统之间的互操作性支持。网络平台。公共语言运行时(CLR)是一种ECMA标准。基类,它描述了指令集和执行环境。净框架。它提供了一组共同的特征,包括对象生命周期管理、垃圾收集,安全,和版本。编译器的支持。净(例如Visual Studio c++,c#,和Visual Basic;大约40种语言已经一定程度的。网络支持)生成CIL代码,然后编译DLL的部署和EXE文件符合可移植可执行(PE)格式。当这些文件是由CLR,它首先翻译CIL为本机代码的执行。

。NET Remoting的组件。净处理远程对象。它允许一个调用远程对象的方法。在远程对象调用方法,必须来源于MarshalByRefObject远程对象。这类似于Java的远程类并确保远程rererence对象可以创建。一个代理(存根)是在创建对象时激活和CLR拦截所有调用对象。CLR知道哪些类是远程,以便它可以处理过程的情况下请求一个新的远程对象和一个本地对象。任何作为参数传递的对象必须实现iSerializable接口,这是analagous Java序列化的类。这将确保对象的数据可以被转换成一个平面网络友好的格式:可以发送的字节数组在网络信息。

创建对象分为两类:服务器激活对象和客户端激活的对象。服务器激活对象不依赖于客户端控制一个对象的生命周期。客户端与客户端激活的对象,不创建一个新对象,使用它,然后删除它。有两种形式的服务器激活对象。一个叫对象完全是无状态的。每创建一个对象的新实例调用。该操作被触发客户端调用对象上的方法。一个单例对象持续不断。相同的实例对象是用于所有客户端请求。服务器创建的对象只有在对象不存在。从那时起,所有客户端请求共享对象。在服务器上创建一个客户端激活的对象(如当客户端请求一个新对象。通过一个新的操作)。它类似于COM +模型,支持多个引用同一个对象和多个不同的客户来自同一类创建的对象。它还支持分布式垃圾回收。

租赁分布式垃圾收集器
。NET Remoting使用租赁的分布式垃圾收集器(LDGC)客户端激活的对象。垃圾收集是不需要服务器激活的对象,因为对象要么持续的时间永远一个方法调用(调用)或(singleton)。租赁管理器管理对象租赁服务器。使用的服务器对象被认为是只要租赁没有过期。如果一个客户想要联系租赁到期时,它必须提供一个赞助对象。客户的赞助对象可以选择延长租约,如果必要的。

垃圾收集器使用对象的以下参数:

InitialLeaseTime:初始远程对象的生命周期(5分钟违约)

LeaseManagePollTime:间隔租赁经理调查leases10秒默认)

sponsorshipTimeOut:等待一个赞助商的时间框架可用(2分钟违约)

每次调用方法,租赁时间设置为马克西姆(租赁时间,过期时间,RenewOnCallTime)。renewOnCallTime将继续租赁的时间在每一个方法调用。请求者(客户端)更新其租赁当leaseTime白白的流逝了。这租约的方法意味着服务器不需要引用计数与COM +一样。

的。NET Remoting组件设计为一个同质环境:之间的通信。净的过程。时间。净支持Web服务。NET remoting不是专门为它设计的。一个扩展名为Web服务增强(WSE),旨在处理基于soap的Web服务。WSE支持以下字母汤的协议和格式:

HTTP:超文本传输协议、TCP / IP通信协议运行

XML:扩展标记语言,数据表示格式

SOAP:简单对象访问协议,协议发送和接收消息和调用函数

WSDL:Web服务定义语言,XML文档定义了可用性服务及其接口

UDDI:通用描述、发现和集成,为发现服务协议

与之相比。净,SOAP只是底层消息传递协议。创建一个。净的web服务,一个写了。净对象如果是由当地客户访问,标志着一个属性,它应该提供给Web客户端。ASP。净,扩展到微软的web服务器(IIS)提供了框架,接受HTTP请求,并将其映射到对象调用。WSDL文档描述可用的服务是通过检查元数据自动生成。网络对象。

的进化。网络设施Windows通信框架(WCF),这是另一个改革提供一个统一的通信框架也支持与其他平台的互操作性。它仍然使用。NET CLR环境和支持库。

与WCF服务在服务实现类,它实现一个或多个方法和包含一个服务契约,它定义了一个客户端可以使用的方法,和数据合同,它定义了数据结构。服务类被编译到一个基于clr的语言。服务类通常是编译成库和运行在一个主机的过程。宿主进程可以之一:

IIS(web服务器)主机进程(必须使用HTTP上的SOAP)的通信协议

窗口激活服务

一个任意的过程

端点定义为服务指定:

一个地址:服务的URL
绑定:协议和安全机制的描述
合同* *:服务合同的名称表明这个端点公开
Windows通信框架提供了一组可能的绑定(通信选项):

绑定	描述
BasicHttpBinding	HTTP上的SOAP(可选HTTPS)
WsHttpBinding	相同但支持可靠的消息传输,安全性和事务
NetTcpBinding	二进制编码SOAP / TCP,支持可靠的消息传输,安全性和事务
完全	与没有肥皂——理想的RESTful HTTP或HTTPS通信;数据XML、JSON或二进制
NetNamedPipesBinding	二进制编码命名管道上的SOAP(多平台不仅WCF-WCF沟通)
NetMsmqBinding	二进制编码的MSMQ之上的SOAP(也不是多平台;WCF-WCF唯一的)
XML Web服务的Java API
Java RMI设计与远程对象进行交互,但建立主要是与Java模型。此外,它不是由web服务和基于http的消息传递。出现了大量的软件来支持基于java的web服务。我们将看看其中的一个概述。jax - ws(XML Web服务的Java API)作为Web服务的Java API设计信息和远程过程调用。它允许一个调用基于Java的web服务使用Java RMI(即。,相对透明的程序员)。jax - ws的一个目标是平台互操作性。API使用SOAP和WSDL。双方不需要Java环境,客户和服务定义的WSDL文档。

创建一个RPC端点
在服务器端,进行下面的步骤来创建一个RPC端点(也就是说,RPC服务客户可用):

定义一个接口(Java接口)

实现服务

创建一个出版商,全心服务的一个实例并发布一个名字

在客户端:

创建一个代理(客户端存根)。wsimport命令以WSDL文档,创建一个客户机存根

编写一个客户端,通过代理创建远程服务的一个实例(存根),调用它的方法

图7。jax - ws调用流
图7。jax - ws调用流
执行流程中使用jax - RPC是几乎所有其他RPC系统的流动除了框架通常是由服务器的web服务器。如图7所示:

Java客户机调用存根上的方法(代理)
存根调用适当的web服务
web服务器被调用并指导jax - ws框架
框架调用实现
该框架的实现返回结果
该框架将结果返回给web服务器
服务器将结果发送给客户端存根
客户端存根返回给调用者的信息
除了肥皂
当肥皂,仍然是广泛部署,许多环境中把它支持机制,要么是更轻的重量,更容易理解,或者适应web交互模型更干净。例如,Google的api支持SOAP接口降至2006年,提供替代的AJAX,xml - rpc和休息。一个匿名的微软员工批评SOAP过于复杂,因为“我们希望我们的工具来阅读它,而不是人”。报价是否准确与否其实并不重要因为SOAP显然是一个复杂和highly-verbose格式。

AJAX
原始设计的web浏览器的一个限制是web页面提供的非动态的交互模型。web浏览器是建立同步equest-response交互模型。发送一个请求到服务器,服务器返回整个页面。只是没有更新部分页面的好方法。唯一可行的方法是利用帧(一旦他们成为可用)和不同的页面加载到每一帧。甚至是笨重和限制性。是什么这是改变了文档对象模型和JavaScript的出现,使得一个以编程方式更改web页面的各个部分。另一个关键因素是需要与服务器进行交互以非阻塞方式,仍然允许用户与页面交互即使底层JavaScript从服务器仍在等待结果。该组件被称为AJAX。
AJAX代表异步JavaScript和XML。让我们看看这些三项:

它是异步的,因为客户端从服务器不会阻塞,等待结果。

AJAX集成到JavaScript和设计为调用浏览器解释一个web页面的一部分。使用HTTPRequest从JavaScript调用AJAX请求。JavaScript也可能修改文档对象模型,定义了页面的样子

数据发送和接收XML文档。

AJAX迎来了众所周知的Web 2.0:高度交互的服务,如谷歌地图,写,和许多其他人。基本上,它允许JavaScript发出HTTP请求,获取和处理结果,页面元素而不刷新整个页面。在大多数浏览器[6]请求的格式:

new XMLHttpRequest()
xmlhttp.open(“HEAD”, “index.html”, true)Tell object:
JavaScript代码告诉你发行的XMLHttpRequest对象类型的请求,请求的URL,函数调用请求的时候,和身体的请求一起发送的信息

注意,AJAX是远离RPC。它并没有提供一个功能接口服务器功能。这也是专门为web浏览器。

休息
虽然SOAP创建自己的消息传递协议,它只是碰巧运输通过HTTP REST(REpresentational State Transfer)的方法是保持网络的原理和使用HTTP协议的核心部分。

原始的HTTP协议已经定义了四个命令,清晰地映射到各种操作,可以进行数据(一个“资源”):

(插入)
(选择)
(更新后)
删除(删除)
其他背后的理念是使用这些HTTP命令请求数据的操作数据和影响。作为HTTP协议的一部分,其他使用url引用对象和操作,因为它们提供天使的命名格式和属性值列表的参数(如。,http://mydomain.com/mydata/getlist?item=123&format=brief)。

在与集团进行交互的一个例子,考虑这些操作:

得到一个用户的友情链接的快照:
HTTP GET / /rpc.bloglines.com/listsubs
HTTP身份验证处理的用户标识和身份验证
获取一个特定订阅信息:
HTTP GET http://rpc.bloglines.com/getitems?s= { subid }
其他模型为面向资源的服务是非常合理的,如博客订阅,亚马逊,flikr del.icio。我们等。

作为一个进一步的例子,考虑这个HTTP操作列表的部分:

HTTP GET //www.parts-depot.com/parts
这个命令将返回一个XML文档,其中包含部分的列表。注意,返回的是没有一个网页,只是一个XML数据结构包含所请求的数据。

<?xml version="1.0"?>
<p:Parts xmlns:p="http://www.parts-depot.com" 
         xmlns:xlink="http://www.w3.org/1999/xlink">
      <Part id="00345" xlink:href="http://www.parts-depot.com/parts/00345"/>
      <Part id="00346" xlink:href="http://www.parts-depot.com/parts/00346"/>
      <Part id="00347" xlink:href="http://www.parts-depot.com/parts/00347"/>
      <Part id="00348" xlink:href="http://www.parts-depot.com/parts/00348"/>
</p:Parts>
特定部分的详细信息,会发送一个HTTP get命令查询特定的部分:

HTTP GET //www.parts-depot.com/parts/00345
这将返回一个特定的信息部分:

<?xml version="1.0"?>
<p:Part xmlns:p="http://www.parts-depot.com"   
        xmlns:xlink="http://www.w3.org/1999/xlink">
      <Part-ID>00345</Part-ID>
      <Name>Widget-A</Name>
      <Description>This part is used within the frap assembly</Description>
      <Specification xlink:href="http://www.parts-depot.com/parts/00345/specification"/>
      <UnitCost currency="USD">0.10</UnitCost>
      <Quantity>10</Quantity>
</p:Part>
注意,这是一个例子和部分查询可以有一部分作为URL参数数量。例如

HTTP GET //www.parts-depot.com/parts?partid=00345
休息不是RPC,而是有一个类似的请求-响应模式。制定的透明度要求,封送数据,并解析响应不属于休息。休息中使用非常广泛的支持和服务,如Yahoo !搜索api,Ruby on Rails,笨蛋,开放活力服务。最后是XM-Sirius电台的编程接口。URL获取频道列表:

svc://Radio/ChannelList
并在一个特定时间特定渠道的信息,你可以请求

svc://Radio/ChannelInfo?sid=001-siriushits1&ts=2012091103205
谷歌协议缓冲区:封送处理
有些时候RPC和web服务是需要的,但一个程序员只是想简化的任务编组和解封网络上的数据。谷歌协议缓冲区用于序列化结构化数据提供了一种有效的机制,使它容易编码数据在网络和解码接收的数据。协议缓冲区是一个紧凑的二进制格式更简单,小,速度比XML。他们是独立于语言的,只定义数据类型。每个消息是一个结构化的数据集名称,类型和值。消息结构定义在一个高层次的格式,类似于许多接口定义语言。然后编译这个文件来为你选择的语言生成转换例程。协议缓冲区中广泛使用谷歌。目前超过48000种不同的消息类型定义。使用它们为被广泛运用的、类似rpc消息传递以及持久性存储,需要将数据转换成标准的串行形式写入到一个文件中。一个协议缓冲区定义的一个例子,从谷歌的协议缓冲区开发者指南:

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
请注意,这只定义了数据结构,而不是功能。一个示例使用这个结构是:

Person person;
person.set_name("John Doe");
person.set_id(1234);
person.set_email("jdoe@example.com");
fstream output("myfile", ios::out | ios::binary);
person.SerializeToOstream(&output);
即使紧凑的XML版本相比,协议缓冲区更有效的在时间和空间解析。同样,从开发者指南,如果我们比较这个XML版本:

<person>
    <name>John Doe</name>
    <email>jdoe@example.com</email>
</person>
这个没有编译的协议缓冲区:

person {
   name: "John Doe"
   email: "jdoe@example.com"
}
协议产生的二进制消息缓冲大约是28字节长,大概需要100 - 200 ns解析。XML版本,相比之下,在69个字节长(2.5倍),从5000年到10000年ns解析(50倍的时间)。

JSON
花药封送处理格式,得到了相当大的声望是JSON。这不是一个二进制格式如谷歌协议缓冲区,因此适合使用在消息通过HTTP传输负载。JSON是基于JavaScript,人类可读和可写,容易解析。这是介绍“无脂替代XML”。目前,转换器存在添加了50多种语言和远程过程调用json - rpc。记住,这只是一个消息传递格式和JSON并没有试图提供RPC库和支持服务发现、绑定、托管和垃圾收集。


## 参考引用

* <http://www.cs.virginia.edu/~zaher/classes/CS656/birrel.pdf>
* <https://www.cs.rutgers.edu/~pxk/417/notes/03-rpc.html>